/*
 * [The "BSD license"]
 *  Copyright (c) 2015 Dan McLaughlin, Mike Lischke
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. The name of the author may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import "Files.stg" // All file specific stuff.

cppTypeInitMap ::= [
    "int":"0",
    "long":"0",
    "float":"0.0f",
    "double":"0.0",
    "bool":"false",
    "short":"0",
    "char":"0",
    default: "nullptr" // anything other than a primitive type is an object
]

LexerHeader(lexer, atn, actionFuncs, sempredFuncs, superClass = {Lexer}) ::= <<
<if (lexer.tokens)>
class <lexer.name>Token {
public:
  enum {
    <lexer.tokens: {k | <k> = <lexer.tokens.(k)>}; separator=", ", wrap, anchor>
  };
};
<endif>

<if (lexer.modes)>
class <lexer.name>Mode {
public:
  enum {
    <lexer.modes: {m | <m> = <i>,}; separator="\n", anchor>
  };
};
<endif>

class <lexer.name> : public <if (superClass)><superClass><else>Lexer<endif> {
public:
  <lexer.name>(CharStream *input);
  ~<lexer.name>();

  virtual std::wstring getGrammarFileName() const override;
  virtual const std::vector\<std::wstring>& getRuleNames() const override;
  
  virtual const std::vector\<std::wstring>& getModeNames() const override;
  virtual const std::vector\<std::wstring>& getTokenNames() const override; // deprecated, use vocabulary instead
  virtual Ref\<dfa::Vocabulary> getVocabulary() const override;
  
  virtual const std::wstring getSerializedATN() const;
  virtual const atn::ATN& getATN() const override;

  <if (actionFuncs)>
  virtual void action(Ref\<RuleContext> context, int ruleIndex, int actionIndex) override;
  <endif>
  <if (sempredFuncs)>
  virtual bool sempred(Ref\<RuleContext> context, int ruleIndex, int predicateIndex) override;  
  <endif>
  
private:
  static std::vector\<dfa::DFA> _decisionToDFA;
  static Ref\<atn::PredictionContextCache> _sharedContextCache;
  static std::vector\<std::wstring> _ruleNames;
  static std::vector\<std::wstring> _tokenNames;
  static std::vector\<std::wstring> _modeNames;
  
  static std::vector\<std::wstring> _literalNames;
  static std::vector\<std::wstring> _symbolicNames;
  static Ref\<dfa::Vocabulary> _vocabulary;
  <atn>
  
  <if (namedActions.members)><namedActions.members>
  <endif>

  // Individual action functions triggered by action() above.
  <if (actionFuncs)>
  <actionFuncs.values; separator="\n">
  <endif>
  
  // Individual semantic predicate functions triggered by sempred() above.
  <if (sempredFuncs)>
  <sempredFuncs.values; separator="\n">
  <endif>
  
  struct Initializer {
    Initializer();
  };
  static Initializer _init;
};
>>

Lexer(lexer, atn, actionFuncs, sempredFuncs, superClass = {Lexer}) ::= <<
<lexer.name>::<lexer.name>(CharStream *input) : <if (superClass)><superClass><else>Lexer<endif>(input) {
  _interpreter = new atn::LexerATNSimulator(this, _atn, _decisionToDFA, _sharedContextCache);
}

<lexer.name>::~<lexer.name>() {
  delete _interpreter;
}

std::wstring <lexer.name>::getGrammarFileName() const {
  return L"<lexer.grammarFileName>";
}

const std::vector\<std::wstring>& <lexer.name>::getRuleNames() const {
  return _ruleNames;
}
  
const std::vector\<std::wstring>& <lexer.name>::getModeNames() const {
  return _modeNames;
}
  
const std::vector\<std::wstring>& <lexer.name>::getTokenNames() const {
  return _tokenNames;
}
  
Ref\<dfa::Vocabulary> <lexer.name>::getVocabulary() const {
  return _vocabulary;
}

const std::wstring <lexer.name>::getSerializedATN() const {
  return _serializedATN;
}

const atn::ATN& <lexer.name>::getATN() const {
  return _atn;
}

<if (actionFuncs)>
void <lexer.name>::action(Ref\<RuleContext> context, int ruleIndex, int actionIndex) {
  switch (ruleIndex) {
    <lexer.actionFuncs.values: {f | case <f.ruleIndex>: <f.name>Action(std::dynamic_pointer_cast\<<f.ctxType>\>(context), actionIndex); break;}; separator="\n">

    default:
      break;
  }
}
<endif>

<if (sempredFuncs)>
bool <lexer.name>::sempred(Ref\<RuleContext> context, int ruleIndex, int predicateIndex) {
  switch (ruleIndex) {
    <lexer.sempredFuncs.values: {f | case <f.ruleIndex>: return <f.name>Sempred(std::dynamic_pointer_cast\<<f.ctxType>\>(context), predicateIndex);}; separator="\n">

    default:
      break;
  }
  return true;
}
<endif>
  
<if (actionFuncs)>
<actionFuncs.values; separator="\n">
<endif>
<if (sempredFuncs)>
<sempredFuncs.values; separator="\n">
<endif>

// Static vars and initialization.
std::vector\<dfa::DFA> <lexer.name>::_decisionToDFA;
Ref\<atn::PredictionContextCache> <lexer.name>::_sharedContextCache = std::make_shared\<atn::PredictionContextCache>();

// We own the ATN which in turn owns the ATN states.
atn::ATN <lexer.name>::_atn;
std::wstring <lexer.name>::_serializedATN;

std::vector\<std::wstring> <lexer.name>::_ruleNames = {
  <lexer.ruleNames: {r | L"<r>"}; separator = ", ", wrap, anchor>
};

std::vector\<std::wstring> <lexer.name>::_modeNames = {
  <lexer.modes: {m | L"<m>"}; separator = ", ", wrap, anchor>
};

std::vector\<std::wstring> <lexer.name>::_literalNames = {
  <lexer.literalNames: {t | L<t>}; null = "L\"\"", separator = ", ", wrap, anchor>
};

std::vector\<std::wstring> <lexer.name>::_symbolicNames = {
  <lexer.symbolicNames: {t | L<t>}; null = "L\"\"", separator = ", ", wrap, anchor>
};

Ref\<dfa::Vocabulary> <lexer.name>::_vocabulary = std::make_shared\<dfa::VocabularyImpl>(_literalNames, _symbolicNames);

std::vector\<std::wstring> <lexer.name>::_tokenNames = []() {
  std::vector\<std::wstring> result;
	for (size_t i = 0; i \< _symbolicNames.size(); ++i) {
		std::wstring name = _vocabulary->getLiteralName(i);
		if (name.empty()) {
			name = _vocabulary->getSymbolicName(i);
		}

		if (name.empty()) {
			_tokenNames.push_back(L"\<INVALID>");
		} else {
      _tokenNames.push_back(name);
    }
	}
  return result;
}();

<lexer.name>::Initializer::Initializer() {
  <atn>
}

<lexer.name>::Initializer <lexer.name>::_init;
>>

RuleActionFunctionHeader(r, actions) ::= <<
void <r.name>Action(Ref\<<r.ctxType>\> context, int actionIndex);
>>

RuleActionFunction(r, actions) ::= <<
void <r.factory.grammar.name>::<r.name>Action(Ref\<<r.ctxType>\> context, int actionIndex) {
  switch (actionIndex) {
    <actions: {index | case <index>: <actions.(index)> break;}; separator="\n">
  
  default:
    break;
    }
}

>>

RuleSempredFunctionHeader(r, actions) ::= <<
bool <r.name>Sempred(Ref\<<r.ctxType>\> context, int predicateIndex);
>>

RuleSempredFunction(r, actions) ::= <<
bool <r.factory.grammar.name>::<r.name>Sempred(Ref\<<r.ctxType>\> context, int predicateIndex) {
  switch (predicateIndex) {
    <actions: {index | case <index>: return <actions.(index)>;}; separator="\n">
    
    default:
      break;
    }
    return true;
}

>>

//--------------------------------------------------------------------------------------------------

ParserHeader(parser, funcs, atn, sempredFuncs, superClass = {Parser}) ::= <<
<if (parser.tokens)>
class <parser.name>Token {
public:
  enum {
    <parser.tokens: {k | <k> = <parser.tokens.(k)>}; separator=", ", wrap, anchor>
  };
};
<endif>

class <parser.name>Rule {
public:
  enum {
    <parser.rules: {r | Rule<r.name; format="cap"> = <r.index>}; separator=", ", wrap, anchor>
  };
};

class <parser.name> : public <superClass> {
public:
  <parser.name>(TokenStream *input);
  ~<parser.name>();

  virtual std::wstring getGrammarFileName() const override;
  virtual const atn::ATN& getATN() const override { return _atn; };
  virtual const std::vector\<std::wstring>& getTokenNames() const override { return _tokenNames; }; // deprecated: use vocabulary instead.
  virtual const std::vector\<std::wstring>& getRuleNames() const override;
  virtual Ref\<dfa::Vocabulary> getVocabulary() const override;
 
  <if(namedActions.members)><namedActions.members><endif>
  <parser.funcs: {f | class <f.name; format = "cap">Context;};  separator = "\n"> <! Forward declare context classes. !>
  
  <funcs; separator = "\n">

  <if (sempredFuncs)>
  virtual bool sempred(Ref\<RuleContext> context, int ruleIndex, int predicateIndex) override;
  <sempredFuncs.values; separator = "\n">
  <endif>

private:
  static std::vector\<dfa::DFA> _decisionToDFA;
  static Ref\<atn::PredictionContextCache> _sharedContextCache;
  static std::vector\<std::wstring> _ruleNames;
  static std::vector\<std::wstring> _tokenNames;
  
  static std::vector\<std::wstring> _literalNames;
  static std::vector\<std::wstring> _symbolicNames;
  static Ref\<dfa::Vocabulary> _vocabulary;
  <atn>
  
  struct Initializer {
    Initializer();
  };
  static Initializer _init;
};
>>

Parser(parser, funcs, atn, sempredFuncs, superClass = {Parser}) ::= <<
using namespace org::antlr::v4::runtime;

<parser.name>::<parser.name>(TokenStream *input) : <superClass>(input) {
  _interpreter = new atn::ParserATNSimulator(this, _atn, _decisionToDFA, _sharedContextCache);
}

<parser.name>::~<parser.name>() {
  delete _interpreter;
}

std::wstring <parser.name>::getGrammarFileName() const {
  return L"<parser.grammarFileName>";
}

const std::vector\<std::wstring>& <parser.name>::getRuleNames() const {
  return _ruleNames;
}

Ref\<dfa::Vocabulary> <parser.name>::getVocabulary() const {
  return _vocabulary;
}

<funcs; separator = "\n\n">

<if (sempredFuncs)>
bool <parser.name>::sempred(Ref\<RuleContext> context, int ruleIndex, int predicateIndex) {
  switch (ruleIndex) {
  <parser.sempredFuncs.values: {f |
  case <f.ruleIndex>: return <f.name>Sempred(std::dynamic_pointer_cast\<<f.ctxType>\>(context), predicateIndex);}; separator="\n">
  
    default:
      break;
  }
  return true;
}

<sempredFuncs.values; separator="\n"><endif>

// Static vars and initialization.
std::vector\<dfa::DFA> <parser.name>::_decisionToDFA;
Ref\<atn::PredictionContextCache> <parser.name>::_sharedContextCache = std::make_shared\<atn::PredictionContextCache>();

// We own the ATN which in turn owns the ATN states.
atn::ATN <parser.name>::_atn;
std::wstring <parser.name>::_serializedATN;

std::vector\<std::wstring> <parser.name>::_ruleNames = {
    <parser.ruleNames: {r | L"<r>"}; separator = ", ", wrap, anchor>
};

std::vector\<std::wstring> <parser.name>::_literalNames = {
  <parser.literalNames: {t | L<t>}; null = "L\"\"", separator = ", ", wrap, anchor>
};

std::vector\<std::wstring> <parser.name>::_symbolicNames = {
  <parser.symbolicNames: {t | L<t>}; null = "L\"\"", separator = ", ", wrap, anchor>
};

Ref\<dfa::Vocabulary> <parser.name>::_vocabulary = std::make_shared\<dfa::VocabularyImpl>(_literalNames, _symbolicNames);

std::vector\<std::wstring> <parser.name>::_tokenNames = []() {
  std::vector\<std::wstring> result;
	for (size_t i = 0; i \< <parser.name>::_symbolicNames.size(); ++i) {
		std::wstring name = <parser.name>::_vocabulary->getLiteralName(i);
		if (name.empty()) {
			name = <parser.name>::_vocabulary->getSymbolicName(i);
		}

		if (name.empty()) {
			result.push_back(L"\<INVALID>");
		} else {
      result.push_back(name);
    }
	}
  return result;
}();

<parser.name>::Initializer::Initializer() {
  <atn>
}

<parser.name>::Initializer <parser.name>::_init;
>>

SerializedATNHeader(model) ::= <<
static atn::ATN _atn;
static std::wstring _serializedATN;
>>

// Constructs the serialized ATN and writes init code for static member vars.
SerializedATN(model) ::= <<
<if (rest(model.segments))>
<model.segments: {segment | static std::wstring serializedATNSegment<i0> = {
  <segment; wrap={<\n>   }>
\};}; separator="\n">
_serializedATN =
  <model.segments: {segment | serializedATNSegment<i0>}; separator=" +\n">;
  
<else>
<! only one segment, can be inlined !>
_serializedATN = {
  <model.serialized; wrap = {<\n>}>
};
<endif>

atn::ATNDeserializer deserializer;
_atn = deserializer.deserialize(_serializedATN);

for (int i = 0; i \< _atn.getNumberOfDecisions(); i++) { <! Rework class ATN to allow standard iterations. !>
  _decisionToDFA.push_back(dfa::DFA(_atn.getDecisionState(i), i));
}
>>

RuleFunctionHeader(currentRule, args, code, locals, ruleCtx, altLabelCtxs, namedActions, finallyAction, postamble, exceptions) ::= <<
<ruleCtx>
<! TODO: untested !><if (altLabelCtxs)><altLabelCtxs: {l | <altLabelCtxs.(l)>}; separator="\n"><endif>
Ref\<<currentRule.ctxType>\> <currentRule.name>(<args; separator=",">);

>>

RuleFunction(currentRule, args, code, locals, ruleCtx, altLabelCtxs, namedActions, finallyAction, postamble, exceptions) ::= <<
<ruleCtx>
<! TODO: untested !><altLabelCtxs: {l | <altLabelCtxs.(l)>}; separator = "\n">
Ref\<<parser.name>::<currentRule.ctxType>\> <parser.name>::<currentRule.name>(<args; separator=",">) {
  Ref\<<currentRule.ctxType>\> result = std::make_shared\<<currentRule.ctxType>\>(_ctx, getState()<currentRule.args:{a | , <a.name>}>);
  enterRule(result, <currentRule.startState>, <parser.name>Rule::Rule<currentRule.name; format = "cap">);
  <namedActions.init>
<! TODO: untested !> <locals; separator = "\n">

  auto onExit = finally([this] {
<! TODO: untested !><if (finallyAction)><finallyAction><endif>
    exitRule();
  });
  try {
<! TODO: untested !><if (currentRule.hasLookaheadBlock)>
    int alt;
    <endif>
    <code>
<! TODO: untested !>   <postamble; separator = "\n">
    <namedActions.after>
  }
  <if (exceptions)>
  <exceptions; separator="\n">
  <else>
  catch (RecognitionException &e) {
    result->exception = std::make_exception_ptr(e);
    _errHandler->reportError(this, e);
    _errHandler->recover(this, e);
  }
  <endif>

  return result;
}
>>

LeftRecursiveRuleFunctionHeader(currentRule, args, code, locals, ruleCtx, altLabelCtxs, namedActions, finallyAction, postamble) ::= <<
<ruleCtx>
<! TODO: untested !><altLabelCtxs: {l | <altLabelCtxs.(l)>}; separator="\n">
Ref\<<currentRule.ctxType>\> <currentRule.name>(<currentRule.args; separator = ", ">);
Ref\<<currentRule.ctxType>\> <currentRule.name>(int precedence<currentRule.args: {a | , <a>}>);
>>

LeftRecursiveRuleFunction(currentRule, args, code, locals, ruleCtx, altLabelCtxs, namedActions, finallyAction, postamble) ::= <<
<ruleCtx>
<altLabelCtxs: {l | <altLabelCtxs.(l)>}; separator="\n">

Ref\<<parser.name>::<currentRule.ctxType>\> <parser.name>::<currentRule.name>(<currentRule.args; separator=", ">) {
<! TODO: currentRule.args untested !>   return <currentRule.name>(0<currentRule.args: {a | , <a.name>}>);
}

Ref\<<parser.name>::<currentRule.ctxType>\> <parser.name>::<currentRule.name>(int precedence<currentRule.args:{a | , <a>}>) {
    Ref\<ParserRuleContext> parentContext = _ctx;
    int parentState = getState();
    Ref\<<parser.name>::<currentRule.ctxType>\> result = std::make_shared\<<currentRule.ctxType>\>(_ctx, parentState<currentRule.args: {a | , <a.name>}>);
    Ref\<<parser.name>::<currentRule.ctxType>\> previousContext = result;
    int startState = <currentRule.startState>;
    enterRecursionRule(result, <currentRule.startState>, <parser.name>Rule::Rule<currentRule.name; format = "cap">, precedence);
  
    <namedActions.init>
<! TODO: untested !>    <locals; separator = "\n">
  
  auto onExit = finally([this, parentContext] {
<! TODO: untested !><if (finallyAction)><finallyAction><endif>
        unrollRecursionContexts(parentContext);
  });
  try {
    <if (currentRule.hasLookaheadBlock)>int alt;<endif>
    <code>
<! TODO: untested !><postamble; separator = "\n">
    <namedActions.after>
  }
  catch (RecognitionException &e) {
    result->exception = std::make_exception_ptr(e);
    _errHandler->reportError(this, e);
    _errHandler->recover(this, e);
  }
  return result;
}
>>

StructDeclHeader(struct, ctorAttrs, attrs, getters, dispatchMethods, interfaces, extensionMembers) ::= <<
class <struct.name> : public <if (contextSuperClass)><contextSuperClass><else>ParserRuleContext<endif><if(interfaces)>, <interfaces; separator=", "><endif> {
public:
  <if (attrs)><attrs:{a | <if (!a.isLocal)><a>;<endif>}; separator="\n"><endif>
  <if (ctorAttrs)><struct.name>(std::weak_ptr\<ParserRuleContext> parent, int invokingState);<endif>
  <struct.name>(std::weak_ptr\<ParserRuleContext> parent, int invokingState<ctorAttrs: {a | , <a>}>);
<if (struct.provideCopyFrom)> <! don't need copy unless we have subclasses !>
  <struct.name>() { }
  void copyFrom(Ref\<<struct.name>\> context);
<endif>

  virtual ssize_t getRuleIndex() const override;
  <getters: {g | <g>}; separator = "\n">

  <dispatchMethods; separator = "\n">
<! TODO: untested !> <extensionMembers; separator = "\n">
private:
  <if (attrs)><attrs: {a | <if (a.isLocal)><a><endif>}; separator = "\n"><endif>
};

>>

StructDecl(struct, ctorAttrs, attrs, getters, dispatchMethods, interfaces, extensionMembers) ::= <<
//----------------- <struct.name> ------------------------------------------------------------------

<if (ctorAttrs)>
<parser.name>::<struct.name>::<struct.name>(std::weak_ptr\<ParserRuleContext> parent, int invokingState)
  : <if (contextSuperClass)><contextSuperClass><else>ParserRuleContext<endif>(parent, invokingState) {
}
<endif>

<parser.name>::<struct.name>::<struct.name>(std::weak_ptr\<ParserRuleContext> parent, int invokingState<ctorAttrs: {a | , <a>}>)
  : <if (contextSuperClass)><contextSuperClass><else>ParserRuleContext<endif>(parent, invokingState) {
  <struct.ctorAttrs: {a | this-><a.name> = <a.name>;}; separator="\n">
}

<getters: {g | <g>}; separator = "\n">

ssize_t <parser.name>::<struct.name>::getRuleIndex() const {
  return (ssize_t)<parser.name>Rule::Rule<struct.derivedFromName; format = "cap">;
}

<if (struct.provideCopyFrom)>
void <parser.name>::<struct.name>::copyFrom(Ref\<<struct.name>\> ctx) {
  <if (contextSuperClass)><contextSuperClass><else>ParserRuleContext<endif>::copyFrom(ctx);
<! TODO: untested !>  <struct.attrs: {a | this-><a.name> = ctx.<a.name>;}; separator = "\n">
}
<endif>
<dispatchMethods; separator = "\n\n">
<! TODO: untested !><extensionMembers; separator = "\n\n">

>>

AltLabelStructDeclHeader(struct, attrs, getters, dispatchMethods) ::= <<
class <struct.name> : public <currentRule.name; format = "cap">Context {
public:
  <struct.name>(Ref\<<currentRule.name; format = "cap">Context> ctx);
  
<! TODO: untested!>  <if (attrs)><attrs: {a | <a>}; separator = "\n">bbb<endif>
  <getters: {g | <g>}; separator = "\n">
  <dispatchMethods; separator = "\n">
};

>>

AltLabelStructDecl(struct, attrs, getters, dispatchMethods) ::= <<
//----------------- <struct.name> ------------------------------------------------------------------

<! TODO: untested !><if (attrs)><attrs: {a | <a>}; separator = "\n"><endif>
<getters: {g | <g>}; separator = "\n">
<struct.factory.grammar.name>::<struct.name>::<struct.name>(Ref\<<currentRule.name; format = "cap">Context> ctx) { copyFrom(ctx); }

<dispatchMethods; separator="\n">
>>


CodeBlockForOuterMostAltHeader(currentOuterMostAltCodeBlock, locals, preamble, ops) ::= "<! Required to exist, but unused. !>"
CodeBlockForOuterMostAlt(currentOuterMostAltCodeBlock, locals, preamble, ops) ::= <<
<if (currentOuterMostAltCodeBlock.altLabel)>
result = std::dynamic_pointer_cast\<<currentRule.ctxType>\>(std::make_shared\<<parser.name>::<currentOuterMostAltCodeBlock.altLabel; format = "cap">Context>(result));
<endif>
enterOuterAlt(result, <currentOuterMostAltCodeBlock.alt.altNum>);
<CodeBlockForAlt(currentAltCodeBlock = currentOuterMostAltCodeBlock, ...)>
>>

CodeBlockForAltHeader(currentAltCodeBlock, locals, preamble, ops) ::= "<! Required to exist, but unused. !>"
CodeBlockForAlt(currentAltCodeBlock, locals, preamble, ops) ::= <<
<! TODO: untested !><locals; separator = "\n">
<! TODO: untested !><preamble; separator = "\n">
<ops; separator = "\n">
>>

LL1AltBlockHeader(choice, preamble, alts, error) ::= "<! Required to exist, but unused. !>"
LL1AltBlock(choice, preamble, alts, error) ::= <<
setState(<choice.stateNumber>);
_errHandler->sync(this);
<! TODO: untested !><if (choice.label)>LL1AltBlock(choice, preamble, alts, error) <labelref(choice.label)> = _input->LT(1);<endif>
<preamble; separator="\n">
switch (_input->LA(1)) {
  <choice.altLook, alts: {look, alt | <cases(ttypes = look)>
    <alt>
    break;
}; separator = "\n">
default:
    <error>
}
>>

LL1OptionalBlock(choice, alts, error) ::= <<LL1OptionalBlock(choice, alts, error)
setState(<choice.stateNumber>);YYY
switch (_input->LA(1)) {
<choice.altLook,alts:{look,alt| <cases(ttypes=look)>
    <alt>
    break;}; separator="\n">
default:
    <error>
}
>>

LL1OptionalBlockSingleAltHeader(choice, expr, alts, preamble, error, followExpr) ::= "<! Required to exist, but unused. !>"
LL1OptionalBlockSingleAlt(choice, expr, alts, preamble, error, followExpr) ::= <<
setState(<choice.stateNumber>);

<preamble; separator = "\n">
if (<expr>) {
    <alts; separator = "\n">
}
>>

LL1StarBlockSingleAltHeader(choice, loopExpr, alts, preamble, iteration) ::= "LL1StarBlockSingleAltHeader"
LL1StarBlockSingleAlt(choice, loopExpr, alts, preamble, iteration) ::= <<
setState(<choice.stateNumber>);
_errHandler->sync(this);
<preamble; separator="\n">
while (<loopExpr>) {
    <alts; separator="\n">
    setState(<choice.loopBackStateNumber>);
    _errHandler->sync(this);
    <iteration>
}
>>

LL1PlusBlockSingleAltHeader(choice, loopExpr, alts, preamble, iteration) ::= "<! Required but unused. !>"
LL1PlusBlockSingleAlt(choice, loopExpr, alts, preamble, iteration) ::= <<
setState(<choice.blockStartStateNumber>); <! alt block decision !>
_errHandler->sync(this);
<preamble; separator="\n">
do {
    <alts; separator="\n">
    setState(<choice.stateNumber>); <! loopback/exit decision !>
    _errHandler->sync(this);
    <iteration>
} while (<loopExpr>);
>>

// LL(*) stuff

AltBlockHeader(choice, preamble, alts, error) ::= "<! Unused but must be present. !>"
AltBlock(choice, preamble, alts, error) ::= <<
setState(<choice.stateNumber>);
_errHandler->sync(this);
<! TODO: untested !><if (choice.label)><labelref(choice.label)> = _input->LT(1);<endif>
<! TODO: untested !><preamble; separator = "\n">
switch (getInterpreter\<atn::ParserATNSimulator>()->adaptivePredict(_input, <choice.decision>, _ctx)) {
<alts: {alt | case <i>:
    <alt>
    break;
}; separator="\n">
}
>>

OptionalBlockHeader(choice, alts, error) ::= "<! Unused but must be present. !>"
OptionalBlock(choice, alts, error) ::= <<
setState(<choice.stateNumber>);
_errHandler->sync(this);

switch (getInterpreter\<atn::ParserATNSimulator>()->adaptivePredict(_input, <choice.decision>, _ctx)) {
<alts: {alt | case <i><if (!choice.ast.greedy)>+1<endif>:
    <alt>
    break;
}; separator = "\n">
}
>>

StarBlockHeader(choice, alts, sync, iteration) ::= "<! Unused but must be present. !>"
StarBlock(choice, alts, sync, iteration) ::= <<
setState(<choice.stateNumber>);
_errHandler->sync(this);
alt = getInterpreter\<atn::ParserATNSimulator>()->adaptivePredict(_input, <choice.decision>, _ctx);
while (alt != <choice.exitAlt> && alt != -1) {
    if ( alt == 1 <if(!choice.ast.greedy)>+ 1<endif>) {
        <iteration>
        <alts> <! should only be one !>
    }
    setState(<choice.loopBackStateNumber>);
    _errHandler->sync(this);
    alt = getInterpreter\<atn::ParserATNSimulator>()->adaptivePredict(_input, <choice.decision>, _ctx);
}
>>

PlusBlockHeader(choice, alts, error) ::= "<! Required to exist, but unused. !>"
PlusBlock(choice, alts, error) ::= <<
setState(<choice.blockStartStateNumber>); <! alt block decision !>
_errHandler->sync(this);
alt = getInterpreter\<atn::ParserATNSimulator>()->adaptivePredict(_input, <choice.decision>, _ctx);
do {
    switch (alt) {
    <alts: {alt | case <i><if (!choice.ast.greedy)> + 1<endif>:
    <alt>
    break;
  }; separator="\n">
    default:
        <error>
    }
    setState(<choice.loopBackStateNumber>); <! loopback/exit decision !>
    _errHandler->sync(this);
    alt = getInterpreter\<atn::ParserATNSimulator>()->adaptivePredict(_input, <choice.decision>, _ctx);
} while (alt != <choice.exitAlt> && alt != -1);
>>

Sync(s) ::= "Sync(s) sync(<s.expecting.name>);"

ThrowNoViableAltHeader(t) ::= "<! Unused but must be present. !>"
ThrowNoViableAlt(t) ::= "throw NoViableAltException(this);"

TestSetInlineHeader(s) ::= "<! Required but unused. !>"
TestSetInline(s) ::= <<
<s.bitsets: {bits | <if (rest(rest(bits.ttypes)))><bitsetBitfieldComparison(s, bits)><else><bitsetInlineComparison(s, bits)><endif>}; separator=" || ">
>>

// Java language spec 15.19 - shift operators mask operands rather than overflow to 0... need range test
testShiftInRange(shiftAmount) ::= <<
((<shiftAmount> & ~(ssize_t)0x3f) == 0)
>>

// produces smaller bytecode only when bits.ttypes contains more than two items
bitsetBitfieldComparison(s, bits) ::= <<
(<testShiftInRange({<offsetShift(s.varName, bits.shift)>})> &&
  ((1L \<\< <offsetShift(s.varName, bits.shift)>) & (<bits.ttypes: {ttype | (1L \<\< <offsetShift(ttype, bits.shift, true)>)}; separator = " | ">)) != 0)
>>

isZero ::= [
  "0": true,
  default: false
]

offsetShift(shiftAmount, offset, prefix = false) ::= <%
<if (!isZero.(offset))>(<if (prefix)><parser.name>Token::<endif><shiftAmount> - <offset>)<else><if (prefix)><parser.name>Token::<endif><shiftAmount><endif>
%>

// produces more efficient bytecode when bits.ttypes contains at most two items
bitsetInlineComparison(s, bits) ::= <%
<bits.ttypes: {ttype | <s.varName> == <parser.name>Token::<ttype>}; separator = " || ">
%>

cases(ttypes) ::= <<
<ttypes: {t | case <parser.name>Token::<t>:}; separator="\n">
>>

InvokeRuleHeader(r, argExprsChunks) ::= "InvokeRuleHeader"

InvokeRule(r, argExprsChunks) ::= <<
setState(<r.stateNumber>); <if(r.labels)><r.labels: {l | <labelref(l)> = }><endif><r.name>(<if(r.ast.options.p)><r.ast.options.p><if(argExprsChunks)>,<endif><endif><argExprsChunks>);
>>

MatchTokenHeader(m) ::= "<! Required but unused. !>"
MatchToken(m) ::= <<
setState(<m.stateNumber>); <if (m.labels)><m.labels: {l | <labelref(l)> = }><endif>match(<parser.name>Token::<m.name>);
>>

MatchSetHeader(m, expr, capture) ::= "<! Required but unused. !>"
MatchSet(m, expr, capture) ::= "<CommonSetStuff(m, expr, capture, false)>"

MatchNotSetHeader(m, expr, capture) ::= "<! Required but unused. !>"
MatchNotSet(m, expr, capture) ::= "<CommonSetStuff(m, expr, capture, true)>"

CommonSetStuff(m, expr, capture, invert) ::= <<
setState(<m.stateNumber>);
<if(m.labels)><m.labels: {l | <labelref(l)> = }>_input->LT(1);<endif>
<capture>
if (<if(invert)><m.varName> \<= 0 || <else>!<endif>(<expr>)) {
    <if(m.labels)><m.labels:{l | <labelref(l)> = (Token)}><endif>_errHandler->recoverInline(this);
}
consume();
>>

WildcardHeader(w) ::= "<! Required but unused. !>"
Wildcard(w) ::= <<
setState(<w.stateNumber>);
<! TODO: w.lables untested!>
<if (w.labels)>Wildcard() <w.labels: {l | <labelref(l)> = }><endif>matchWildcard();
>>

// ACTION STUFF

ActionHeader(a, foo, chunks) ::= "<chunks>"
Action(a, foo, chunks) ::= "<chunks>"

ArgAction(a, chunks) ::= "ArgAction(a, chunks) <chunks>"

SemPredHeader(p, chunks, failChunks) ::= "<! Required but unused. !>"
SemPred(p, chunks, failChunks) ::= <<
setState(<p.stateNumber>);

<! TODO: failChunks + p.msg untested !>
if (!(<chunks>)) throw FailedPredicateException(this, <p.predicate><if (failChunks)>, <failChunks><elseif (p.msg)>, L<p.msg><endif>);
>>

ExceptionClauseHeader(e, catchArg, catchAction) ::= "<! Required but unused. !>"
ExceptionClause(e, catchArg, catchAction) ::= <<
catch (<catchArg>) {
    <catchAction>
}
>>

// Lexer actions are not associated with model objects.

LexerSkipCommand()  ::= "skip();"
LexerMoreCommand()  ::= "more();"
LexerPopModeCommand() ::= "popMode();"

LexerTypeCommand(arg, grammar)      ::= "_type = <grammar.name>Token::<arg>;"
LexerChannelCommand(arg, grammar)   ::= "_channel = <arg>;"
LexerModeCommand(arg, grammar)      ::= "_mode = <grammar.name>Mode::<arg>;"
LexerPushModeCommand(arg, grammar)  ::= "pushMode(<grammar.name>Mode::<arg>);"

// TODO: untested
ActionTextHeader(t) ::= "<t.text>"
ActionText(t) ::= "<t.text>"

ActionTemplateHeader(t) ::= "<! Unused but must be present. !>"
ActionTemplate(t) ::= "<t.st>"

ArgRef(a) ::= "ArgRef(a) result.<a.name>"
LocalRef(a) ::= "LocalRef(a) result.<a.name>"
RetValueRef(a) ::= "RetValueRef(a) result.<a.name>"
QRetValueRef(a) ::= "QRetValueRef(a) <ctx(a)>.<a.dict>.<a.name>"
/** How to translate $tokenLabel */
TokenRef(t) ::= "TokenRef(t) <ctx(t)>.<t.name>"
LabelRef(t) ::= "LabelRef(t) <ctx(t)>.<t.name>"
ListLabelRef(t) ::= "ListLabelRef(t) <ctx(t)>.<ListLabelName(t.name)>"
SetAttr(s,rhsChunks) ::= "SetAttr(s,rhsChunks) <ctx(s)>.<s.name> = <rhsChunks>;"

InputSymbolType() ::= "<file.InputSymbolType; null = {Token}> *"

TokenPropertyRef_text(t) ::= "TokenPropertyRef_text(t) (<ctx(t)>.<t.label> != nullptr ? <ctx(t)>.<t.label>.getText() : null)"
TokenPropertyRef_type(t) ::= "TokenPropertyRef_type(t) (<ctx(t)>.<t.label> != nullptr ? <ctx(t)>.<t.label>.getType() : 0)"
TokenPropertyRef_line(t) ::= "TokenPropertyRef_line(t) (<ctx(t)>.<t.label> != nullptr ? <ctx(t)>.<t.label>.getLine() : 0)"
TokenPropertyRef_pos(t) ::= "TokenPropertyRef_pos(t) (<ctx(t)>.<t.label> != nullptr ? <ctx(t)>.<t.label>.getCharPositionInLine() : 0)"
TokenPropertyRef_channel(t) ::= "TokenPropertyRef_channel(t) (<ctx(t)>.<t.label> != nullptr ? <ctx(t)>.<t.label>.getChannel() : 0)"
TokenPropertyRef_index(t) ::= "TokenPropertyRef_index(t) (<ctx(t)>.<t.label> != nullptr ? <ctx(t)>.<t.label>.getTokenIndex() : 0)"
TokenPropertyRef_int(t) ::= "TokenPropertyRef_int(t) (<ctx(t)>.<t.label> != nullptr ? Integer.valueOf(<ctx(t)>.<t.label>.getText()) : 0)"

RulePropertyRef_start(r) ::= "RulePropertyRef_start(r) (<ctx(r)>.<r.label> != nullptr ? (<ctx(r)>.<r.label>.start) : null)"
RulePropertyRef_stop(r)  ::= "RulePropertyRef_stop(r)   (<ctx(r)>.<r.label> != nullptr ? (<ctx(r)>.<r.label>.stop) : null)"
RulePropertyRef_text(r)  ::= "RulePropertyRef_text(r)   (<ctx(r)>.<r.label> != nullptr ? _input->getText(<ctx(r)>.<r.label>.start,<ctx(r)>.<r.label>.stop) : null)"
RulePropertyRef_ctx(r)   ::= "RulePropertyRef_ctx(r)<ctx(r)>.<r.label>"

ThisRulePropertyRef_start(r) ::= "ThisRulePropertyRef_start(r) result->start"
ThisRulePropertyRef_stop(r)  ::= "ThisRulePropertyRef_stop(r)   result->stop"
ThisRulePropertyRef_text(r)  ::= "ThisRulePropertyRef_text(r)   input->getText(result->start, _input->LT(-1))"
ThisRulePropertyRef_ctx(r)   ::= "ThisRulePropertyRef_ctx(r)    result"

NonLocalAttrRef(s) ::= "NonLocalAttrRef(s) ((<s.ruleName; format=\"cap\">Context)getInvokingContext(<s.ruleIndex>)).<s.name>"
SetNonLocalAttr(s, rhsChunks) ::=
    "SetNonLocalAttr(s, rhsChunks) ((<s.ruleName; format=\"cap\">Context)getInvokingContext(<s.ruleIndex>)).<s.name> = <rhsChunks>;"

AddToLabelListHeader(a) ::= "<! Required but unused. !>"
AddToLabelList(a) ::= <<
<ctx(a.label)>-><a.listName>.push_back(<labelref(a.label)>);
>>

TokenLabelType() ::= "Ref\<<file.TokenLabelType; null = {Token}>>"

TokenDeclHeader(t) ::= "<TokenLabelType()> <t.name>" 
TokenDecl(t) ::= "<! Variable Declaration !>"

TokenTypeDeclHeader(t) ::= "<! Local Variable !>"
TokenTypeDecl(t) ::= "ssize_t <t.name>;"

TokenListDeclHeader(t) ::= "std::vector\<Ref\<Token>> <t.name>;"
TokenListDecl(t) ::= "<! Variable Declaration !>"

RuleContextDeclHeader(r) ::= "Ref\<<parser.name>::<r.ctxName>> <r.name>;"
RuleContextDecl(r) ::= "<! Variable Declaration !>"

RuleContextListDeclHeader(rdecl) ::= "std::vector\<Ref\<<rdecl.ctxName>>> <rdecl.name>;"
RuleContextListDecl(rdecl) ::= "<! Variable Declaration !>"

ContextTokenGetterDeclHeader(t) ::= "Ref\<tree::TerminalNode> <t.name>();"
ContextTokenGetterDecl(t) ::= <<
Ref\<tree::TerminalNode> <parser.name>::<t.ctx.name>::<t.name>() {
  return getToken(<parser.name>Token::<t.name>, 0);
}

>>

ContextTokenListGetterDeclHeader(t) ::= "std::vector\<Ref\<tree::TerminalNode>> <t.name>();"
ContextTokenListGetterDecl(t) ::= <<
std::vector\<Ref\<tree::TerminalNode>\> <parser.name>::<t.ctx.name>::<t.name>() {
  return getTokens(<parser.name>Token::<t.name>);
}

>>

ContextTokenListIndexedGetterDeclHeader(t) ::= "Ref\<tree::TerminalNode> <t.name>(int i);"
ContextTokenListIndexedGetterDecl(t)  ::= <<
Ref\<tree::TerminalNode> <parser.name>::<t.ctx.name>::<t.name>(int i) {
  return getToken(<parser.name>Token::<t.name>, (size_t)i);
}

>>

ContextRuleGetterDeclHeader(r) ::= "Ref\<<r.ctxName>> <r.name>();"
ContextRuleGetterDecl(r) ::= <<
<! Note: ctxName is the name of the context to return, while ctx is the owning context. !>
Ref\<<parser.name>::<r.ctxName>\> <parser.name>::<r.ctx.name>::<r.name>() {
  return getRuleContext\<<parser.name>::<r.ctxName>\>(0);
}

>>

ContextRuleListGetterDeclHeader(r) ::= "std::vector\<Ref\<<r.ctxName>>> <r.name>();"
ContextRuleListGetterDecl(r) ::= <<
std::vector\<Ref\<<parser.name>::<r.ctxName>\>> <parser.name>::<r.ctx.name>::<r.name>() {
  return getRuleContexts\<<parser.name>::<r.ctxName>\>();
}

>>

ContextRuleListIndexedGetterDeclHeader(r) ::= "Ref\<<r.ctxName>> <r.name>(int i);"
ContextRuleListIndexedGetterDecl(r) ::= <<
Ref\<<parser.name>::<r.ctxName>\> <parser.name>::<r.ctx.name>::<r.name>(int i) {
  return getRuleContext\<<parser.name>::<r.ctxName>\>((size_t)i);
}

>>

LexerRuleContext() ::= "RuleContext"

// The rule context name is the rule followed by a suffix; e.g. r becomes rContext.
RuleContextNameSuffix() ::= "Context"

ImplicitTokenLabel(tokenName) ::= <<
<tokenName; format = "lower">Token
>>

ImplicitRuleLabel(ruleName) ::= "<ruleName>Context"
ImplicitSetLabel(id) ::= "ImplicitSetLabel(id) _tset<id>"
ListLabelName(label) ::= "<label>"

CaptureNextToken(d) ::= "CaptureNextToken(d) <d.varName> = _input->LT(1);"

CaptureNextTokenTypeHeader(d) ::= "<! Required but unused. !>"
CaptureNextTokenType(d) ::= "<d.varName> = _input->LA(1);"

ListenerDispatchMethodHeader(method) ::= <<
virtual void <if (method.isEnter)>enter<else>exit<endif>Rule(Ref\<tree::ParseTreeListener> listener) override;
>>
ListenerDispatchMethod(method) ::= <<
void <method.factory.grammar.name>::<struct.name>::<if (method.isEnter)>enter<else>exit<endif>Rule(Ref\<tree::ParseTreeListener> listener) {
  auto parserListener = std::dynamic_pointer_cast\<<parser.grammarName>Listener>(listener);
  if (parserListener)
    parserListener-><if(method.isEnter)>enter<else>exit<endif><struct.derivedFromName; format="cap">(this);
}
>>

VisitorDispatchMethodHeader(method) ::= <<

template \<typename T>
T* accept(tree::ParseTreeVisitor\<T> *visitor) {
  if (dynamic_cast\<<parser.grammarName>Visitor\<T>*>(visitor) != nullptr)
    return ((<parser.grammarName>Visitor\<T> *)visitor)->visit<struct.derivedFromName; format="cap">(this);
  else
    return visitor->visitChildren(this);
}
>>
VisitorDispatchMethod(method) ::= "<! Template function, must be implemented in the header. !>"

AttributeDeclHeader(d) ::= "<d.type> <d.name><if(d.initValue)> = <d.initValue><endif>"
AttributeDecl(d) ::= "<d.type> <d.name>"

/** If we don't know location of label def x, use this template */
labelref(x) ::= "<if (!x.isLocal)>result<endif>-><x.name>"

/** For any action chunk, what is correctly-typed context struct ptr? */
ctx(actionChunk) ::= "result"

// used for left-recursive rules
recRuleAltPredicate(ruleName,opPrec) ::= "precpred(_ctx, <opPrec>)"
recRuleSetReturnAction(src,name) ::= "recRuleSetReturnAction(src,name) $<name>=$<src>.<name>;"
recRuleSetStopToken() ::= "_ctx->stop = _input->LT(-1);"

recRuleAltStartAction(ruleName, ctxName, label) ::= <<
result = std::make_shared\<<ctxName>Context>(parentContext, parentState);
<if (label)>result-><label> = previousContext;<endif>
pushNewRecursionContext(result, startState, <parser.name>Rule::Rule<ruleName; format = "cap">);
>>

recRuleLabeledAltStartAction(ruleName, currentAltLabel, label) ::= <<recRuleLabeledAltStartAction
result = std::make_shared\<<currentAltLabel; format = "cap">Context>(new <ruleName; format="cap">Context(_parentctx, _parentState));
<if(label)>((<currentAltLabel; format="cap">Context*)result).<label> = previousContext;<endif>
pushNewRecursionContext(result, _startState, RULE_<ruleName>);
>>

recRuleReplaceContext(ctxName) ::= <<recRuleReplaceContext
result = std::make_shared\<<ctxName>Context>(_localctx);
ctx = result;
previousContext = result;
>>

recRuleSetPrevCtx() ::= <<
if (!_parseListeners.empty())
  triggerExitRuleEvent();
previousContext = result;
>>

/** Using a type to init value map, try to init a type; if not in table
 *  must be an object, default value is "null".
 */
initValue(typeName) ::= <<
<cppTypeInitMap.(typeName)>
>>

