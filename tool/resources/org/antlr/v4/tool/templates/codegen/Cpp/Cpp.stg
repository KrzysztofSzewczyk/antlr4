/*
 * [The "BSD license"]
 *  Copyright (c) 2015 Dan McLaughlin, Mike Lischke
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. The name of the author may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import "Files.stg" // All file specific stuff.

cppTypeInitMap ::= [
	"int":"0",
	"long":"0",
	"float":"0.0f",
	"double":"0.0",
	"bool":"false",
	"short":"0",
	"char":"0",
	default: "nullptr" // anything other than a primitive type is an object
]

// Lexer class templates.
DefaultLexerSuperClass(s) ::= "Lexer"

LexerHeader(lexer, atn, actionFuncs, sempredFuncs, superClass) ::= <<
<if (lexer.tokens)>
enum class <lexer.name>Token {
  <lexer.tokens: {k | <k> = <lexer.tokens.(k)>}; separator=", ", wrap, anchor>
};
<endif>

<if (lexer.modes)>
enum class <lexer.name>Mode {
  <rest(lexer.modes): {m | <m> = <i>,}; separator="\n", anchor>
};
<endif>

class <lexer.name> : public <if (superClass)><superClass><else>Lexer<endif> {
public:
  <lexer.name>(CharStream *input);
  ~<lexer.name>();

  virtual std::wstring getGrammarFileName() const override;
  virtual const std::vector\<std::wstring>& getRuleNames() const override;
  virtual const std::vector\<std::wstring>& getModeNames() const override;
  virtual const std::vector\<std::wstring>& getTokenNames() const override;
  
  virtual const std::wstring getSerializedATN() const;
  virtual atn::ATN* getATN() const override;

  <if (actionFuncs)>
  virtual void action(RuleContext *context, int ruleIndex, int actionIndex) override;
  <endif>
  <if (sempredFuncs)>
  virtual bool sempred(RuleContext *context, int ruleIndex, int predicateIndex) override;  
  <endif>
  
private:
  static std::vector\<dfa::DFA*> _decisionToDFA;
  static atn::PredictionContextCache _sharedContextCache;
  static std::vector\<std::wstring> _ruleNames;
  static std::vector\<std::wstring> _tokenNames;
  static std::vector\<std::wstring> _modeNames;
  <atn>
  
  atn::LexerATNSimulator *_interpreter;
  
  <if (namedActions.members)><namedActions.members>
  <endif>

  // Individual action functions triggered by action() above.
  <if (actionFuncs)>
  <actionFuncs.values; separator="\n">
  <endif>
  
  // Individual semantic predicate functions triggered by sempred() above.
  <if (sempredFuncs)>
  <sempredFuncs.values; separator="\n">
  <endif>
  
  struct Initializer {
    Initializer();
  };
  static Initializer _init;
};
>>

Lexer(lexer, atn, actionFuncs, sempredFuncs, superClass) ::= <<
<lexer.name>::<lexer.name>(CharStream *input) : <if (superClass)><superClass><else>Lexer<endif>(input) {
  _interpreter = new atn::LexerATNSimulator(this, _atn, _decisionToDFA, &_sharedContextCache);
}

<lexer.name>::~<lexer.name>() {
  delete _interpreter;
}

std::wstring <lexer.name>::getGrammarFileName() const {
  return L"<lexer.grammarFileName>";
}

const std::vector\<std::wstring>& <lexer.name>::getRuleNames() const {
  return _ruleNames;
}
  
const std::vector\<std::wstring>& <lexer.name>::getModeNames() const {
  return _modeNames;
}
  
const std::vector\<std::wstring>& <lexer.name>::getTokenNames() const {
  return _tokenNames;
}
  
const std::wstring <lexer.name>::getSerializedATN() const {
  return _serializedATN;
}

atn::ATN* <lexer.name>::getATN() const{
  return _atn;
}

<if (actionFuncs)>
void <lexer.name>::action(RuleContext *context, int ruleIndex, int actionIndex) {
  switch (ruleIndex) {
    <lexer.actionFuncs.values: {f | case <f.ruleIndex>: <f.name>Action((<f.ctxType> *)context, actionIndex); break;}; separator="\n">

    default:
      break;
  }
}
<endif>

<if (sempredFuncs)>
bool <lexer.name>::sempred(RuleContext *context, int ruleIndex, int predicateIndex) {
  switch (ruleIndex) {
    <lexer.sempredFuncs.values: {f | case <f.ruleIndex>: return <f.name>Sempred((<f.ctxType> *)context, predicateIndex);}; separator="\n">

    default:
      break;
  }
  return true;
}
<endif>
  
<if (actionFuncs)>
<actionFuncs.values; separator="\n">
<endif>
<if (sempredFuncs)>
<sempredFuncs.values; separator="\n">
<endif>

// Static vars and initialization.
std::vector\<dfa::DFA*> <lexer.name>::_decisionToDFA;
atn::PredictionContextCache <lexer.name>::_sharedContextCache;
atn::ATN *<lexer.name>::_atn;
std::wstring <lexer.name>::_serializedATN;

std::vector\<std::wstring> <lexer.name>::_ruleNames = {
    <lexer.ruleNames: {r | L"<r>"}; separator = ", ", wrap, anchor>
};
std::vector\<std::wstring> <lexer.name>::_modeNames = {
    <lexer.modes: {m | L"<m>"}; separator = ", ", wrap, anchor>
};
std::vector\<std::wstring> <lexer.name>::_tokenNames;
/*
std::vector\<std::wstring> <lexer.name>::_tokenNames = { <! TODO: replace by vocabulary (see Java.stg). !>
    <lexer.tokenNames: {t | <t>}; separator = ", ", wrap, anchor>
};
*/

<lexer.name>::Initializer::Initializer() {
  <atn>
}
>>

RuleActionFunctionHeader(r, actions) ::= <<
void <r.name>Action(<r.ctxType> *context, int actionIndex);
>>

RuleActionFunction(r, actions) ::= <<
void <r.factory.grammar.name>::<r.name>Action(<r.ctxType> *context, int actionIndex) {
  switch (actionIndex) {
    <actions: {index | case <index>: <actions.(index)> break;}; separator="\n">
  
  default:
    break;
	}
}

>>

RuleSempredFunctionHeader(r, actions) ::= <<
bool <r.name>Sempred(<r.ctxType> *context, int predicateIndex);
>>

RuleSempredFunction(r, actions) ::= <<
bool <r.factory.grammar.name>::<r.name>Sempred(<r.ctxType> *context, int predicateIndex) {
  switch (predicateIndex) {
    <actions: {index | case <index>: return <actions.(index)>;}; separator="\n">
    
    default:
      break;
	}
	return true;
}

>>

//--------------------------------------------------------------------------------------------------

DefaultParserSuperClass(s) ::= "Parser" // Is that used at all?

ParserHeader(parser, funcs, atn, sempredFuncs, superClass = {Parser}) ::= <<
<if (parser.tokens)>
enum class <parser.name>Token {
  <parser.tokens: {k | <k> = <parser.tokens.(k)>}; separator=", ", wrap, anchor>
};
<endif>

enum class <parser.name>Rule {
  <parser.rules: {r | Rule<r.name; format="cap"> = <r.index>}; separator=", ", wrap, anchor>
};

class <parser.name> : public <superClass> {
public:
  <parser.name>(TokenStream *input);
  ~<parser.name>();

  virtual std::wstring getGrammarFileName() const override;
  virtual const std::vector\<std::wstring>& getRuleNames() const override;
 
  <if(namedActions.members)><namedActions.members><endif>
  <parser.funcs: {f | class <f.name; format = "cap">Context;};  separator = "\n"> <! Forward declare context classes. !>
  
  <funcs; separator = "\n">

  <if (sempredFuncs)>
  virtual bool sempred(RuleContext *context, int ruleIndex, int predicateIndex) override;
  <sempredFuncs.values; separator = "\n">
  <endif>

private:
  static std::vector\<dfa::DFA*> _decisionToDFA;
  static atn::PredictionContextCache _sharedContextCache;
  static std::vector\<std::wstring> _ruleNames;
  <atn>
  
  atn::ParserATNSimulator *_interpreter;
  
  struct Initializer {
    Initializer();
  };
  static Initializer _init;
};
>>

Parser(parser, funcs, atn, sempredFuncs, superClass = {Parser}) ::= <<
using namespace org::antlr::v4::runtime;

<parser.name>::<parser.name>(TokenStream *input) : <superClass>(input) {
  _interpreter = new atn::ParserATNSimulator(this, _atn, _decisionToDFA, &_sharedContextCache);
}

<parser.name>::~<parser.name>() {
  delete _interpreter;
}

std::wstring <parser.name>::getGrammarFileName() const {
  return L"<parser.grammarFileName>";
}

const std::vector\<std::wstring>& <parser.name>::getRuleNames() const {
  return _ruleNames;
}

<funcs; separator = "\n\n">

<if (sempredFuncs)>
bool <parser.name>::sempred(RuleContext *context, int ruleIndex, int predicateIndex) {
  switch (ruleIndex) {
  <parser.sempredFuncs.values: {f |
  case <f.ruleIndex>: return <f.name>Sempred((<f.ctxType> *)context, predicateIndex);}; separator="\n">
  
    default:
      break;
  }
  return true;
}

<sempredFuncs.values; separator="\n"><endif>

// Static vars and initialization.
std::vector\<dfa::DFA*> <parser.name>::_decisionToDFA;
atn::PredictionContextCache <parser.name>::_sharedContextCache;
atn::ATN *<parser.name>::_atn;
std::wstring <parser.name>::_serializedATN;

std::vector\<std::wstring> <parser.name>::_ruleNames = {
    <parser.ruleNames: {r | L"<r>"}; separator = ", ", wrap, anchor>
};

<parser.name>::Initializer::Initializer() {
  <atn>
}
>>

SerializedATNHeader(model) ::= <<
static atn::ATN *_atn;
static std::wstring _serializedATN;
>>

// Constructs the serialized ATN and writes init code for static member vars.
SerializedATN(model) ::= <<
<if (rest(model.segments))>
<model.segments: {segment | static std::wstring _serializedATNSegment<i0> =
  "<segment; wrap={"+<\n><\t>"}>";}; separator="\n">
_serializedATN = Utils.join(
  std::wstring {
    <model.segments: {segment | _serializedATNSegment<i0>}; separator=",\n">
  },
  ""
);
<else>
<! only one segment, can be inlined !>
_serializedATN = L"<model.serialized; wrap = {"<\n>  "}>";
<endif>

atn::ATNDeserializer deserializer;
_atn = deserializer.deserialize(_serializedATN);

for (int i = 0; i \< _atn->getNumberOfDecisions(); i++) { <! Rework class ATN to allow standard iterations. !>
  _decisionToDFA.push_back(new dfa::DFA(_atn->getDecisionState(i), i));
}
>>

RuleFunctionHeader(currentRule, code, locals, ruleCtx, altLabelCtxs, namedActions, finallyAction, postamble, exceptions) ::= <<
<ruleCtx>
<! TODO: untested !><if (altLabelCtxs)><altLabelCtxs: {l | <altLabelCtxs.(l)>}; separator="\n"><endif>
std::shared_ptr\<<currentRule.ctxType>\> <currentRule.name>(<currentRule.args; separator = ",">);

>>

RuleFunction(currentRule, code, locals, ruleCtx, altLabelCtxs, namedActions, finallyAction, postamble, exceptions) ::= <<
<ruleCtx>
<! TODO: untested !><altLabelCtxs: {l | <altLabelCtxs.(l)>}; separator = "\n">
std::shared_ptr\<<parser.name>::<currentRule.ctxType>\> <parser.name>::<currentRule.name>(<currentRule.args; separator = ",">) {
  std::shared_ptr\<<currentRule.ctxType>\> result(new <currentRule.ctxType>(_ctx, getState()<currentRule.args:{a | , <a.name>}>));
  enterRule(result.get(), <currentRule.startState>, (int)<parser.name>Rule::Rule<currentRule.name; format = "cap">);
  <namedActions.init>
<! TODO: untested !> <locals; separator = "\n">

  auto onExit = finally([this] {
<! TODO: untested !><if (finallyAction)><finallyAction><endif>
    exitRule();
  });
  try {
<! TODO: untested !><if (currentRule.hasLookaheadBlock)>
    int alt;
    <endif>
    <code>
<! TODO: untested !>   <postamble; separator = "\n">
    <namedActions.after>
  }
  <if (exceptions)>
  <exceptions; separator="\n">
  <else>
  catch (RecognitionException *re) {
    result->exception = re;
    _errHandler->reportError(this, re);
    _errHandler->recover(this, re);
  }
  <endif>

  return result;
}
>>

LeftRecursiveRuleFunctionHeader(currentRule, code, locals, ruleCtx, altLabelCtxs,	namedActions, finallyAction, postamble) ::= <<
<ruleCtx>
<! TODO: untested !><altLabelCtxs: {l | <altLabelCtxs.(l)>}; separator="\n">
std::shared_ptr\<<currentRule.ctxType>\> <currentRule.name>(<currentRule.args; separator = ", ">);
std::shared_ptr\<<currentRule.ctxType>\> <currentRule.name>(int precedence<currentRule.args: {a | , <a>}>);
>>

LeftRecursiveRuleFunction(currentRule, code, locals, ruleCtx, altLabelCtxs,	namedActions, finallyAction, postamble) ::= <<
<ruleCtx>
<altLabelCtxs: {l | <altLabelCtxs.(l)>}; separator="\n">

std::shared_ptr\<<parser.name>::<currentRule.ctxType>\> <parser.name>::<currentRule.name>(<currentRule.args; separator=", ">) {
<! TODO: currentRule.args untested !>	return <currentRule.name>(0<currentRule.args: {a | , <a.name>}>);
}

std::shared_ptr\<<parser.name>::<currentRule.ctxType>\> <parser.name>::<currentRule.name>(int precedence<currentRule.args:{a | , <a>}>) {
	ParserRuleContext *parentContext = _ctx;
	int parentState = getState();
	std::shared_ptr\<<parser.name>::<currentRule.ctxType>\> result(new <currentRule.ctxType>(_ctx, parentState<currentRule.args: {a | , <a.name>}>));
	std::shared_ptr\<<parser.name>::<currentRule.ctxType>\> previousContext = result;
	int startState = <currentRule.startState>;
	enterRecursionRule(result.get(), <currentRule.startState>, (int)<parser.name>Rule::Rule<currentRule.name; format = "cap">, precedence);
  
	<namedActions.init>
<! TODO: untested !>	<locals; separator = "\n">
  
  auto onExit = finally([this, parentContext] {
<! TODO: untested !><if (finallyAction)><finallyAction><endif>
		unrollRecursionContexts(parentContext);
  });
  try {
    <if (currentRule.hasLookaheadBlock)>int alt;<endif>
    <code>
<! TODO: untested !><postamble; separator = "\n">
    <namedActions.after>
  }
  catch (RecognitionException *re) {
    result->exception = re;
    _errHandler->reportError(this, re);
    _errHandler->recover(this, re);
  }
  return result;
}
>>

StructDeclHeader(struct, attrs, getters, dispatchMethods, interfaces, extensionMembers, superClass = {ParserRuleContext}) ::= <<
class <struct.name> : public <superClass><if (interfaces)><interfaces; separator=", "><endif> {
public:
<! TODO: untested !>  <if (struct.ctorAttrs)><struct.name>(ParserRuleContext *parent, int invokingState);<endif>
<! TODO: struct.ctorAttrs untested !>  <struct.name>(ParserRuleContext *parent, int invokingState<struct.ctorAttrs: {a | , <a>}>);
  <if (struct.provideCopyFrom)><struct.name>() { } <! don't need copy unless we have subclasses !> <! TODO: untested !>
  void copyFrom(<struct.name> *context);
  <endif>

  virtual int getRuleIndex() override;
<! TODO: untested !>  <if (attrs)><attrs: {a | <a>}; separator = "\n"><endif>
  <getters: {g | <g>}; separator = "\n">

  <dispatchMethods; separator = "\n">
<! TODO: untested !>  <extensionMembers; separator = "\n">
};
>>

StructDecl(struct, attrs, getters, dispatchMethods, interfaces, extensionMembers, superClass = {ParserRuleContext}) ::= <<
//----------------- <struct.name> ------------------------------------------------------------------

<! TODO: untested !> <if (struct.ctorAttrs)>
<parser.name>::<struct.name>::<struct.name>(ParserRuleContext *parent, int invokingState) {
  : <superClass>(parent, invokingState);
}
<endif>

<parser.name>::<struct.name>::<struct.name>(ParserRuleContext *parent, int invokingState<struct.ctorAttrs: {a | , <a>}>)
  : <superClass>(parent, invokingState) {
<! TODO: untested !>  <struct.ctorAttrs: {a | this-\><a.name> = <a.name>;}; separator="\n">
}

<! TODO: untested!><attrs: {a | <a>}; separator = "\n">
<getters: {g | <g>}; separator = "\n">

int <parser.name>::<struct.name>::getRuleIndex() {
  return static_cast\<int>(<parser.name>Rule::Rule<struct.derivedFromName; format = "cap">);
}

<! TODO: untested !><if(struct.provideCopyFrom)>
<struct.factory.grammar.name>::<struct.name>() { }
void copyFrom(<struct.name> *ctx) {
  <superClass>.copyFrom(ctx);
  <struct.attrs: {a | this-><a.name> = ctx.<a.name>;}; separator = "\n">
}
<endif>
<dispatchMethods; separator = "\n\n">
<! TODO: untested !><extensionMembers; separator = "\n\n">
>>

CodeBlockForOuterMostAltHeader(currentOuterMostAltCodeBlock, locals, preamble, ops) ::= <<
<! Required to exist, but unused. !>
>>

CodeBlockForOuterMostAlt(currentOuterMostAltCodeBlock, locals, preamble, ops) ::= <<
<! TODO: untested !><if (currentOuterMostAltCodeBlock.altLabel)>result.reset(new <currentOuterMostAltCodeBlock.altLabel; format = "cap">Context(result));<endif>
enterOuterAlt(result.get(), <currentOuterMostAltCodeBlock.alt.altNum>);
<CodeBlockForAlt(currentAltCodeBlock = currentOuterMostAltCodeBlock, ...)>
>>

CodeBlockForAltHeader(currentAltCodeBlock, locals, preamble, ops) ::= <<
<! Required to exist, but unused. !>
>>

CodeBlockForAlt(currentAltCodeBlock, locals, preamble, ops) ::= <<
<! TODO: untested !><locals; separator = "\n">
<! TODO: untested !><preamble; separator = "\n">
<ops; separator = "\n">
>>

LL1AltBlock(choice, preamble, alts, error) ::= <<
setState(<choice.stateNumber>);
_errHandler->sync(this);
<if (choice.label)><labelref(choice.label)> = _input.LT(1);<endif>
<preamble; separator="\n">
switch (_input.LA(1)) {
  <choice.altLook, alts: {look, alt | <cases(ttypes = look)>
	<alt>
	break;
}; separator = "\n">
default:
	<error>
}
>>

LL1OptionalBlock(choice, alts, error) ::= <<
setState(<choice.stateNumber>);YYY
switch (_input.LA(1)) {
<choice.altLook,alts:{look,alt| <cases(ttypes=look)>
	<alt>
	break;}; separator="\n">
default:
	<error>
}
>>

LL1OptionalBlockSingleAlt(choice, expr, alts, preamble, error, followExpr) ::= <<
setState(<choice.stateNumber>);ZZZ

<preamble; separator="\n">
if (<expr>) {
	<alts; separator="\n">
}
>>

LL1StarBlock(choice, alts) ::= <<
setState(<choice.stateNumber>);AAA
_errHandler.sync(this);
<choice.loopLabel>:
while (true) {
	switch (_input.LA(1)) {
	<choice.altLook,alts:{look,alt| <cases(look)>
	<alt>
	break;}; separator="\n">
	<cases(choice.exitLook)>
		break <choice.loopLabel>;
	}
	setState(<choice.loopBackStateNumber>);
	_errHandler.sync(this);
}
>>

LL1StarBlockSingleAlt(choice, loopExpr, alts, preamble, iteration) ::= <<
setState(<choice.stateNumber>);BBB
_errHandler.sync(this);
<preamble; separator="\n">
while (<loopExpr>) {
	<alts; separator="\n">
	setState(<choice.loopBackStateNumber>);
	_errHandler.sync(this);
	<iteration>
}
>>

LL1PlusBlock(choice, alts, iteration, loopExpr, error) ::= <<
setState(<choice.blockStartStateNumber>);CCC <! alt block decision !>
_errHandler.sync(this);
do {
	switch (_input.LA(1)) {
	<choice.altLook,alts:{look,alt| <cases(look)>
	<alt>
	break;}; separator="\n">
	default:
		<error>
	}
	setState(<choice.stateNumber>);
	_errHandler.sync(this);
	<iteration>
} while ( <loopExpr> );
>>

LL1PlusBlockSingleAlt(choice, loopExpr, alts, preamble, iteration) ::= <<
setState(<choice.blockStartStateNumber>);DDD <! alt block decision !>
_errHandler.sync(this);
<preamble; separator="\n">
do {
	<alts; separator="\n">
	setState(<choice.stateNumber>); <! loopback/exit decision !>
	_errHandler.sync(this);
	<iteration>
} while ( <loopExpr> );
>>

// LL(*) stuff

AltBlockHeader(choice, preamble, alts, error) ::= <<
AltBlockHeader
>>

AltBlock(choice, preamble, alts, error) ::= <<
setState(<choice.stateNumber>);
_errHandler->sync(this);
<! TODO: untested !><if (choice.label)><labelref(choice.label)> = _input.LT(1);<endif>
<! TODO: untested !><preamble; separator = "\n">
switch (getInterpreter()->adaptivePredict(_input, <choice.decision>, _ctx)) {
<alts: {alt | case <i>:
	<alt>
	break;
}; separator="\n">
}
>>

OptionalBlockHeader(choice, alts, error) ::= <<
OptionalBlockHeader
>>
OptionalBlock(choice, alts, error) ::= <<
setState(<choice.stateNumber>);
_errHandler->sync(this);

switch (getInterpreter()->adaptivePredict(_input, <choice.decision>, _ctx)) {
<alts: {alt | case <i><if (!choice.ast.greedy)>+1<endif>:
	<alt>
	break;
}; separator = "\n">
}
>>

StarBlockHeader(choice, alts, sync, iteration) ::= <<
StarBlockHeader
>>

StarBlock(choice, alts, sync, iteration) ::= <<
setState(<choice.stateNumber>);
_errHandler->sync(this);
alt = getInterpreter()->adaptivePredict(_input, <choice.decision>, _ctx);
while (alt != <choice.exitAlt> && alt != -1) {
	if ( alt == 1 <if(!choice.ast.greedy)>+ 1<endif>) {
		<iteration>
		<alts> <! should only be one !>
	}
	setState(<choice.loopBackStateNumber>);
	_errHandler->sync(this);
	alt = getInterpreter()->adaptivePredict(_input, <choice.decision>, _ctx);
}
>>

PlusBlockHeader(choice, alts, error) ::= <<
<! Required to exist, but unused. !>
>>

PlusBlock(choice, alts, error) ::= <<
setState(<choice.blockStartStateNumber>); <! alt block decision !>
_errHandler->sync(this);
alt = getInterpreter()->adaptivePredict(_input, <choice.decision>, _ctx);
do {
	switch (alt) {
	<alts: {alt | case <i><if (!choice.ast.greedy)> + 1<endif>:
	<alt>
	break;
  }; separator="\n">
	default:
		<error>
	}
	setState(<choice.loopBackStateNumber>); <! loopback/exit decision !>
	_errHandler->sync(this);
	alt = getInterpreter()->adaptivePredict(_input, <choice.decision>, _ctx);
} while (alt != <choice.exitAlt> && alt != -1);
>>

Sync(s) ::= "sync(<s.expecting.name>);"

ThrowNoViableAltHeader(t) ::= "ThrowNoViableAltHeader"
ThrowNoViableAlt(t) ::= "throw new NoViableAltException(this);"

TestSetInline(s) ::= <<
<s.bitsets:{bits | <if(rest(rest(bits.ttypes)))><bitsetBitfieldComparison(s, bits)><else><bitsetInlineComparison(s, bits)><endif>}; separator=" || ">
>>

// Java language spec 15.19 - shift operators mask operands rather than overflow to 0... need range test
testShiftInRange(shiftAmount) ::= <<
((<shiftAmount>) & ~0x3f) == 0
>>

// produces smaller bytecode only when bits.ttypes contains more than two items
bitsetBitfieldComparison(s, bits) ::= <%
(<testShiftInRange({<offsetShift(s.varName, bits.shift)>})> && ((1L \<\< <offsetShift(s.varName, bits.shift)>) & (<bits.ttypes:{ttype | (1L \<\< <offsetShift(ttype, bits.shift)>)}; separator=" | ">)) != 0)
%>

isZero ::= [
  "0": true,
  default: false
]

offsetShift(shiftAmount, offset) ::= <%
<if(!isZero.(offset))>(<shiftAmount> - <offset>)<else><shiftAmount><endif>
%>

// produces more efficient bytecode when bits.ttypes contains at most two items
bitsetInlineComparison(s, bits) ::= <%
<bits.ttypes:{ttype | <s.varName>==<ttype>}; separator=" || ">
%>

cases(ttypes) ::= <<
<ttypes:{t | case <t>:}; separator="\n">
>>

InvokeRuleHeader(r, argExprsChunks) ::= <<
InvokeRuleHeader
>>

InvokeRule(r, argExprsChunks) ::= <<
setState(<r.stateNumber>); <if(r.labels)><r.labels: {l | <labelref(l)> = }><endif><r.name>(<if(r.ast.options.p)><r.ast.options.p><if(argExprsChunks)>,<endif><endif><argExprsChunks>);
>>

MatchTokenHeader(m) ::= <<
MatchTokenHeader
>>

MatchToken(m) ::= <<
setState(<m.stateNumber>); <if (m.labels)><m.labels: {l | <labelref(l)> = }><endif>match((int)<parser.name>Token::<m.name>);
>>

MatchSet(m, expr, capture) ::= "<CommonSetStuff(m, expr, capture, false)>"

MatchNotSet(m, expr, capture) ::= "<CommonSetStuff(m, expr, capture, true)>"

CommonSetStuff(m, expr, capture, invert) ::= <<
setState(<m.stateNumber>);
<if(m.labels)><m.labels:{l | <labelref(l)> = }>_input.LT(1);<endif>
<capture>
if ( <if(invert)><m.varName> \<= 0 || <else>!<endif>(<expr>) ) {
	<if(m.labels)><m.labels:{l | <labelref(l)> = (Token)}><endif>_errHandler.recoverInline(this);
}
consume();
>>

Wildcard(w) ::= <<
setState(<w.stateNumber>);
<if(w.labels)><w.labels: {l | <labelref(l)> = }><endif>matchWildcard();
>>

// ACTION STUFF

ActionHeader(a, foo, chunks) ::= "<chunks>"
Action(a, foo, chunks) ::= "<chunks>"

ArgAction(a, chunks) ::= "<chunks>"

SemPredHeader(p, chunks, failChunks) ::= <<
SemPredHeader
>>

SemPred(p, chunks, failChunks) ::= <<
setState(<p.stateNumber>);

<! TODO: failChunks + p.msg untested !>
if (!(<chunks>)) throw new FailedPredicateException(this, L<p.predicate><if (failChunks)>, <failChunks><elseif (p.msg)>, L<p.msg><endif>);
>>

ExceptionClauseHeader(e, catchArg, catchAction) ::= "ExceptionClauseHeader"
ExceptionClause(e, catchArg, catchAction) ::= <<
catch (<catchArg>) {
	<catchAction>
}
>>

// Lexer actions are not associated with model objects.

LexerSkipCommand()  ::= "skip();"
LexerMoreCommand()  ::= "more();"
LexerPopModeCommand() ::= "popMode();"

LexerTypeCommand(arg)      ::= "_type = <arg>;"
LexerChannelCommand(arg)   ::= "_channel = <arg>;"
LexerModeCommand(arg)      ::= "_mode = <arg>;"
LexerPushModeCommand(arg)  ::= "pushMode(<arg>);"

ActionTextHeader(t) ::= "<t.text>"
ActionText(t) ::= "<t.text>"

ActionTemplateHeader(t) ::= "ActionTemplateHeader"
ActionTemplate(t) ::= "<t.st>"

ArgRef(a) ::= "result.<a.name>"
LocalRef(a) ::= "result.<a.name>"
RetValueRef(a) ::= "result.<a.name>"
QRetValueRef(a) ::= "<ctx(a)>.<a.dict>.<a.name>"
/** How to translate $tokenLabel */
TokenRef(t) ::= "<ctx(t)>.<t.name>"
LabelRef(t) ::= "<ctx(t)>.<t.name>"
ListLabelRef(t) ::= "<ctx(t)>.<ListLabelName(t.name)>"
SetAttr(s,rhsChunks) ::= "<ctx(s)>.<s.name> = <rhsChunks>;"

TokenLabelType() ::= "<file.TokenLabelType; null = {Token}>"
InputSymbolType() ::= "<file.InputSymbolType; null = {Token}>"

TokenPropertyRef_text(t) ::= "(<ctx(t)>.<t.label> != nullptr ? <ctx(t)>.<t.label>.getText() : null)"
TokenPropertyRef_type(t) ::= "(<ctx(t)>.<t.label> != nullptr ? <ctx(t)>.<t.label>.getType() : 0)"
TokenPropertyRef_line(t) ::= "(<ctx(t)>.<t.label> != nullptr ? <ctx(t)>.<t.label>.getLine() : 0)"
TokenPropertyRef_pos(t) ::= "(<ctx(t)>.<t.label> != nullptr ? <ctx(t)>.<t.label>.getCharPositionInLine() : 0)"
TokenPropertyRef_channel(t) ::= "(<ctx(t)>.<t.label> != nullptr ? <ctx(t)>.<t.label>.getChannel() : 0)"
TokenPropertyRef_index(t) ::= "(<ctx(t)>.<t.label> != nullptr ? <ctx(t)>.<t.label>.getTokenIndex() : 0)"
TokenPropertyRef_int(t) ::= "(<ctx(t)>.<t.label> != nullptr ? Integer.valueOf(<ctx(t)>.<t.label>.getText()) : 0)"

RulePropertyRef_start(r) ::= "(<ctx(r)>.<r.label> != nullptr ? (<ctx(r)>.<r.label>.start) : null)"
RulePropertyRef_stop(r)	 ::= "(<ctx(r)>.<r.label> != nullptr ? (<ctx(r)>.<r.label>.stop) : null)"
RulePropertyRef_text(r)	 ::= "(<ctx(r)>.<r.label> != nullptr ? _input.getText(<ctx(r)>.<r.label>.start,<ctx(r)>.<r.label>.stop) : null)"
RulePropertyRef_ctx(r)	 ::= "<ctx(r)>.<r.label>"

ThisRulePropertyRef_start(r) ::= "result->start"
ThisRulePropertyRef_stop(r)	 ::= "result->stop"
ThisRulePropertyRef_text(r)	 ::= "_input->getText(result->start, _input->LT(-1))"
ThisRulePropertyRef_ctx(r)	 ::= "result"

NonLocalAttrRef(s) ::= "((<s.ruleName; format=\"cap\">Context)getInvokingContext(<s.ruleIndex>)).<s.name>"
SetNonLocalAttr(s, rhsChunks) ::=
	"((<s.ruleName; format=\"cap\">Context)getInvokingContext(<s.ruleIndex>)).<s.name> = <rhsChunks>;"

AddToLabelList(a) ::= "<ctx(a.label)>.<a.listName>.add(<labelref(a.label)>);"

TokenDecl(t) ::= "<TokenLabelType()> <t.name>;"
TokenTypeDecl(t) ::= "int <t.name>;"
TokenListDecl(t) ::= "std::vector\<Token *> <t.name>;"
RuleContextDecl(r) ::= "<r.ctxName> <r.name>;"
RuleContextListDecl(rdecl) ::= "std::vector\<<rdecl.ctxName> *> <rdecl.name>;"

ContextTokenGetterDeclHeader(t) ::= "tree::TerminalNode* <t.name>();"
ContextTokenGetterDecl(t) ::= <<
tree::TerminalNode* <parser.name>::<t.ctx.name>::<t.name>() {
  return getToken((int)<parser.name>Token::<t.name>, 0);
}

>>

ContextTokenListGetterDeclHeader(t) ::= "std::vector\<tree::TerminalNode *> <t.name>();"
ContextTokenListGetterDecl(t) ::= <<
std::vector\<tree::TerminalNode *> <parser.name>::<t.ctx.name>::<t.name>() {
  return getTokens((int)<parser.name>Token::<t.name>);
}

>>

ContextTokenListIndexedGetterDeclHeader(t) ::= "tree::TerminalNode* <t.name>(int i);"
ContextTokenListIndexedGetterDecl(t)  ::= <<
tree::TerminalNode* <parser.name>::<t.ctx.name>::<t.name>(int i) {
  return getToken((int)<parser.name>Token::<t.name>, i);
}

>>

ContextRuleGetterDeclHeader(r) ::= "<r.ctxName>* <r.name>();"
ContextRuleGetterDecl(r) ::= <<
<! Note: ctxName is the name of the context to return, while ctx is the owning context. !>
<parser.name>::<r.ctxName>* <parser.name>::<r.ctx.name>::<r.name>() {
  return getRuleContext\<<parser.name>::<r.ctxName>\>(0);
}

>>

ContextRuleListGetterDeclHeader(r) ::= "std::vector\<<r.ctxName>*> <r.name>();"
ContextRuleListGetterDecl(r) ::= <<
std::vector\<<parser.name>::<r.ctxName>*> <parser.name>::<r.ctx.name>::<r.name>() {
  return getRuleContexts\<<parser.name>::<r.ctxName>\>();
}

>>

ContextRuleListIndexedGetterDeclHeader(r) ::= <<
<r.ctxName>* <r.name>(int i);
>>

ContextRuleListIndexedGetterDecl(r) ::= <<
<parser.name>::<r.ctxName>* <parser.name>::<r.ctx.name>::<r.name>(int i) {
  return getRuleContext\<<parser.name>::<r.ctxName>\>(i);
}

>>

LexerRuleContext() ::= "RuleContext"

// The rule context name is the rule followed by a suffix; e.g.	r becomes rContext.
RuleContextNameSuffix() ::= "Context"

ImplicitTokenLabel(tokenName) ::= "<tokenName>"
ImplicitRuleLabel(ruleName) ::= "<ruleName>"
ImplicitSetLabel(id) ::= "_tset<id>"
ListLabelName(label) ::= "<label>"

CaptureNextToken(d) ::= "<d.varName> = _input.LT(1);"
CaptureNextTokenType(d) ::= "<d.varName> = _input.LA(1);"

AltLabelStructDecl(struct,attrs,getters,dispatchMethods) ::= <<
class <struct.name> : public <currentRule.name; format = "cap">Context {
	<attrs: {a | <a>}; separator = "\n">
	<getters: {g | <g>}; separator = "\n">
	public <struct.name>(<currentRule.name; format = "cap">Context ctx) { copyFrom(ctx); }
	<dispatchMethods; separator="\n">
};
>>

ListenerDispatchMethodHeader(method) ::= <<
virtual void <if (method.isEnter)>enter<else>exit<endif>Rule(tree::ParseTreeListener *listener) override;
>>

ListenerDispatchMethod(method) ::= <<
void <method.factory.grammar.name>::<struct.name>::<if (method.isEnter)>enter<else>exit<endif>Rule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast\<<parser.grammarName>Listener*>(listener);
  if (parserListener != nullptr)
    parserListener-><if(method.isEnter)>enter<else>exit<endif><struct.derivedFromName; format="cap">(this);
}
>>

VisitorDispatchMethodHeader(method) ::= <<

template \<typename T>
T* accept(tree::ParseTreeVisitor\<T> *visitor) {
  if (dynamic_cast\<<parser.grammarName>Visitor\<T>*>(visitor) != nullptr)
    return ((<parser.grammarName>Visitor\<T> *)visitor)->visit<struct.derivedFromName; format="cap">(this);
  else
    return visitor->visitChildren(this);
}
>>

VisitorDispatchMethod(method) ::= <<
<! Template function, must be implemented in the header. !>
>>

AttributeDeclHeader(d) ::= "" // Unused
AttributeDecl(d) ::= <<
// Ignoring specified rule return value: <d.decl>, defined for parser rule: <d.ctx.derivedFromName>;

>>

/** If we don't know location of label def x, use this template */
labelref(x) ::= "<if (!x.isLocal)>((<x.ctx.name>)result).<endif><x.name>"

/** For any action chunk, what is correctly-typed context struct ptr? */
ctx(actionChunk) ::= "((<actionChunk.ctx.name>)result)"

// used for left-recursive rules
recRuleAltPredicate(ruleName,opPrec) ::= "precpred(_ctx, <opPrec>)"
recRuleSetReturnAction(src,name) ::= "$<name>=$<src>.<name>;"
recRuleSetStopToken() ::= "_ctx->stop = _input->LT(-1);"

recRuleAltStartAction(ruleName, ctxName, label) ::= <<
result.reset(new <ctxName>Context(parentContext, parentState));
<if (label)>result-><label> = previousContext;<endif>
pushNewRecursionContext(result.get(), startState, (int)<parser.name>Rule::Rule<ruleName; format = "cap">);
>>

recRuleLabeledAltStartAction(ruleName, currentAltLabel, label) ::= <<
result.reset(new <currentAltLabel; format = "cap">Context(new <ruleName; format="cap">Context(_parentctx, _parentState)));
<if(label)>((<currentAltLabel; format="cap">Context*)result).<label> = previousContext;<endif>
pushNewRecursionContext(result, _startState, RULE_<ruleName>);
>>

recRuleReplaceContext(ctxName) ::= <<
result.reset(new <ctxName>Context(_localctx));
_ctx = result;
previousContext = result;
>>

recRuleSetPrevCtx() ::= <<
if (!_parseListeners.empty())
  triggerExitRuleEvent();
previousContext = result;
>>

/** Using a type to init value map, try to init a type; if not in table
 *	must be an object, default value is "null".
 */
initValue(typeName) ::= <<
<cppTypeInitMap.(typeName)>
>>

