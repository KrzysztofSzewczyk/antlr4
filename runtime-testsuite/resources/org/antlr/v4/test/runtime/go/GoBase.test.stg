

string(text) ::= <<
"<escape.(text)>"
>>

writeBoolean(o) ::= "<if(o && !isEmpty.(o))>true<else>false<endif>"

writeln(s) ::= <<fmt.Println(<s>);>>

write(s) ::= <<fmt.Print(<s>);>>

False() ::= "false"

True() ::= "true"

Not(v) ::= "!<v>"

Assert(s) ::= <<assert(<s>);>>

Cast(t,v) ::= "((<t>)<v>)"

Append(a,b) ::= "<a> + <b>"

Concat(a,b) ::= "<a><b>"

DeclareLocal(s,v) ::= "Object <s> = <v>;"

AssertIsList(v) ::= "List\<?> __ttt__ = <v>;" // just use type system

AssignLocal(s,v) ::= "<s> = <v>;"

InitIntMember(n,v) ::= <%int <n> = <v>;%>

InitBooleanMember(n,v) ::= <%bool <n> = <v>;%>

GetMember(n) ::= <%this.<n>%>

SetMember(n,v) ::= <%this.<n> = <v>;%>

AddMember(n,v) ::= <%this.<n> += <v>;%>

PlusMember(v,n) ::= <%<v> + this.<n>%>

MemberEquals(n,v) ::= <%this.<n> == <v>%>

ModMemberEquals(n,m,v) ::= <%this.<n> % <m> == <v>%>

ModMemberNotEquals(n,m,v) ::= <%this.<n> % <m> != <v>%>

DumpDFA() ::= "this.DumpDFA();"

Pass() ::= ""

StringList() ::= "List\<String>"

BuildParseTrees() ::= "SetBuildParseTree(true);"

BailErrorStrategy() ::= <%SetErrorHandler(new BailErrorStrategy());%>

ToStringTree(s) ::= <%<s>.toStringTree(this)%>

Column() ::= "this.GetCharPositionInLine()"

Text() ::= "this.GetText()"

ValEquals(a,b) ::= <%<a>==<b>%>

TextEquals(a) ::= <%this.GetText().equals("<a>")%>

PlusText(a) ::= <%"<a>" + this.GetText()%>

InputText() ::= "this._input.GetText()"

LTEquals(i, v) ::= <%this._input.LT(<i>).GetText().equals(<v>)%>

LANotEquals(i, v) ::= <%this._input.LA(<i>)!=<v>%>

TokenStartColumnEquals(i) ::= <%this._tokenStartCharPositionInLine==<i>%>

ImportListener(X) ::= ""

GetExpectedTokenNames() ::= "this.GetExpectedTokens().toString(this.tokenNames)"

RuleInvocationStack() ::= "GetRuleInvocationStack()"

LL_EXACT_AMBIG_DETECTION() ::= <<_interp.SetPredictionMode(PredictionModeLL_EXACT_AMBIG_DETECTION);>>

ParserPropertyMember() ::= <<
@members {
bool Property() {
  return true;
}
}
>>

PositionAdjustingLexer() ::= <<

 //@Override
func (this *PositionAdjustingLexer) NextToken() *Token {
	if (!(_interp instanceof PositionAdjustingLexerATNSimulator)) {
		_interp = new PositionAdjustingLexerATNSimulator(this, _ATN, _decisionToDFA, _sharedContextCache);
	}

	return super.nextToken();
}

@Override
func (this *PositionAdjustingLexer) Emit() *Token {
	switch (_type) {
	case TOKENS:
		HandleAcceptPositionForKeyword("tokens");

	case LABEL:
		HandleAcceptPositionForIdentifier();
	}

	return super.emit();
}

func (this *PositionAdjustingLexer) HandleAcceptPositionForIdentifier() bool {
	String tokenText = GetText();
	int identifierLength = 0;
	for (identifierLength \< tokenText.length() && isIdentifierChar(tokenText.charAt(identifierLength))) {
		identifierLength++;
	}

	if (GetInputStream().Index() > _tokenStartCharIndex + identifierLength) {
		int offset = identifierLength - 1;
		GetInterpreter().ResetAcceptPosition(GetInputStream(), _tokenStartCharIndex + offset, _tokenStartLine, _tokenStartCharPositionInLine + offset);
		return true;
	}

	return false;
}

func (this *PositionAdjustingLexer) HandleAcceptPositionForKeyword(keyword string) bool {
	if (GetInputStream().Index() > _tokenStartCharIndex + keyword.length()) {
		int offset = keyword.length() - 1;
		this.GetInterpreter().ResetAcceptPosition(GetInputStream(), _tokenStartCharIndex + offset, _tokenStartLine, _tokenStartCharPositionInLine + offset);
		return true;
	}

	return false;
}

@Override
PositionAdjustingLexerATNSimulator GetInterpreter() {
	return (PositionAdjustingLexerATNSimulator)super.GetInterpreter();
}

bool isIdentifierChar(char c) {
	return Character.isLetterOrDigit(c) || c == '_';
}

type PositionAdjustingLexerATNSimulator struct {
    *antlr4.LexerATNSimulator
}

func NewPositionAdjustingLexerATNSimulator(recog antlr4.ILexer, atn *antlr4.ATN,
    decisionToDFA []*antlr4.DFA, sharedContextCache *PredictionContextCache) *PositionAdjustingLexerATNSimulator {
    super(recog, atn, decisionToDFA, sharedContextCache);
}

func ResetAcceptPosition(input CharStream, index, line, charPositionInLine int) {
    input.seek(index);
    this.line = line;
    this.charPositionInLine = charPositionInLine;
    consume(input);
}

>>

BasicListener(X) ::= <<
type LeafListener extends TBaseListener {
	func visitTerminal(TerminalNode node) {
		fmt.Println(node.GetSymbol().GetText());
	}
}
>>

WalkListener(s) ::= <<
ParseTreeWalker walker = new ParseTreeWalker();
walker.walk(new LeafListener(), <s>);
>>

TokenGetterListener(X) ::= <<
type LeafListener extends TBaseListener {
	func ExitA(TParser.AContext ctx) {
		if (ctx.GetChildCount()==2)
			fmt.Printf("%s %s %s",ctx.INT(0).GetSymbol().GetText(),
				ctx.INT(1).GetSymbol().GetText(),ctx.INT());
		else
			fmt.Println(ctx.ID().GetSymbol());
	}
}
>>

RuleGetterListener(X) ::= <<
type LeafListener extends TBaseListener {
	func ExitA(TParser.AContext ctx) {
		if (ctx.GetChildCount()==2) {
			fmt.Printf("%s %s %s",ctx.b(0).start.GetText(),
				ctx.b(1).start.GetText(),ctx.b().Get(0).start.GetText());
		} else
			fmt.Println(ctx.b(0).start.GetText());
	}
}
>>


LRListener(X) ::= <<
type LeafListener extends TBaseListener {
	func ExitE(TParser.EContext ctx) {
		if (ctx.GetChildCount()==3) {
			fmt.Printf("%s %s %s\n",ctx.e(0).start.GetText(),
				ctx.e(1).start.GetText(), ctx.e().Get(0).start.GetText());
		} else
			fmt.Println(ctx.INT().GetSymbol().GetText());
	}
}
>>

LRWithLabelsListener(X) ::= <<
type LeafListener extends TBaseListener {
	func ExitCall(TParser.CallContext ctx) {
		fmt.Printf("%s %s",ctx.e().start.GetText(),ctx.eList());
	}
	func ExitInt(TParser.IntContext ctx) {
		fmt.Println(ctx.INT().GetSymbol().GetText());
	}
}
>>

DeclareContextListGettersFunction() ::= <<
func foo() {
	SContext s = null;
	List\<? extends AContext> a = s.a();
	List\<? extends BContext> b = s.b();
}
>>

Declare_foo() ::= <<
	func foo() {fmt.Println("foo");}
>>

Invoke_foo() ::= "foo();"

Declare_pred() ::= <<bool pred(bool v) {
	fmt.Println("eval="+v);
	return v;
}
>>

Invoke_pred(v) ::= <<this.pred(<v>)>>

IgnoredTests ::= [
	default: false
]

isEmpty ::= [
	"": true,
	default: false
]
