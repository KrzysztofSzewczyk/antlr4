IgnoredTests ::= [
	default: false
]

TestFile(file) ::= <<
/* This file is generated by TestGenerator, any edits will be overwritten by the next generation. */
package org.antlr.v4.test.runtime.cpp;

import org.junit.Ignore;
import org.junit.Test;
import static org.junit.Assert.*;

<if(file.Options.("ImportErrorQueue"))>
import org.antlr.v4.test.runtime.java.ErrorQueue;
<endif>
<if(file.Options.("ImportGrammar"))>
import org.antlr.v4.tool.Grammar;
<endif>

@SuppressWarnings("unused")
public class Test<file.name> extends BaseCppTest {

	<file.tests:{test | <test>}; separator="\n", wrap, anchor>

}
>>

LexerTestMethod(test) ::= <<
/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
<testAnnotations(test)>
public void test<test.name>() throws Exception {
	mkdir(tmpdir);

<test.SlaveGrammars:{grammar |
	String slave_<grammar> = <writeStringLiteral(test.SlaveGrammars.(grammar))>;
	writeFile(tmpdir, "<grammar>.g4", slave_<grammar>);
	}; separator="\n">
<test.Grammar:{grammar |
	<buildStringLiteral(test.Grammar.(grammar), "grammar")>

<if(test.AfterGrammar)>
	<test.AfterGrammar>
<endif>
	String input =<writeStringLiteral(test.Input)>;
	String found = execLexer("<grammar>.g4", grammar, "<grammar><if(test.Options.("CombinedGrammar"))>Lexer<endif>", input, <writeBoolean(test.Options.("ShowDFA"))>);
	assertEquals(<writeStringLiteral(test.Output)>, found);
	<if(!isEmpty.(test.Errors))>
	assertEquals(<writeStringLiteral(test.Errors)>, this.stderrDuringParse);
	<else>
	assertNull(this.stderrDuringParse);
	<endif>
	}>
}

>>

CompositeLexerTestMethod(test) ::= <<
<LexerTestMethod(test)>
>>

ParserTestMethod(test) ::= <<
/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
<testAnnotations(test)>
public void test<test.name>() throws Exception {
	mkdir(tmpdir);

<test.SlaveGrammars:{grammar |
	String slave_<grammar> =<writeStringLiteral(test.SlaveGrammars.(grammar))>;
<if(test.Options.("SlaveIsLexer"))>
	rawGenerateAndBuildRecognizer("<grammar>.g4", slave_<grammar>, null, "<grammar>");
<else>
	writeFile(tmpdir, "<grammar>.g4", slave_<grammar>);
<endif>
	}; separator="\n">
<test.Grammar:{grammar |
	<buildStringLiteral(test.Grammar.(grammar), "grammar")>

	<test.AfterGrammar>

	String input =<writeStringLiteral(test.Input)>;
	String found = execParser("<grammar>.g4", grammar, "<grammar><if(!test.slaveIsLexer)>Parser<endif>", "<if(test.slaveIsLexer)><first(test.slaveGrammars).grammarName><else><grammar>Lexer<endif>", "<grammar>Listener", "<grammar>Visitor", "<test.Rule>", input, <writeBoolean(test.Options.("Debug"))>);

	assertEquals(<writeStringLiteral(test.Output)>, found);
	<if(!isEmpty.(test.Errors))>
	assertEquals(<writeStringLiteral(test.Errors)>, this.stderrDuringParse);
	<else>
	assertNull(this.stderrDuringParse);
	<endif>
	}>
}

>>

CompositeParserTestMethod(test) ::= <<
<ParserTestMethod(test)>
>>

AbstractParserTestMethod(test) ::= <<
/* this file and method are generated, any edit will be overwritten by the next generation */
String test<test.name>(String input) throws Exception {
	String grammar = <test.grammar.lines:{ line | "<line>};separator="\\n\" +\n", wrap, anchor>";
	return execParser("<test.grammar.grammarName>.g4", grammar, "<test.grammar.grammarName>Parser", "<test.grammar.grammarName>Lexer", "<test.startRule>", input, <test.debug>);
}

>>

ConcreteParserTestMethod(test) ::= <<
/* this file and method are generated, any edit will be overwritten by the next generation */
@Test
public void test<test.name>() throws Exception {
	String found = test<test.baseName>("<test.input>");
	assertEquals("<test.expectedOutput>", found);
	<if(test.expectedErrors)>
	assertEquals("<test.expectedErrors>", this.stderrDuringParse);
	<else>
	assertNull(this.stderrDuringParse);
	<endif>
}

>>

testAnnotations(test) ::= <%
@Test
<if(test.Options.("Ignore"))>
<\n>@Ignore(<writeStringLiteral(test.Options.("Ignore"))>)
<elseif(IgnoredTests.(({<file.name>.<test.name>})))>
<\n>@Ignore(<writeStringLiteral(IgnoredTests.(({<file.name>.<test.name>})))>)
<endif>
%>

buildStringLiteral(text, variable) ::= <<
StringBuilder <variable>Builder = new StringBuilder(<strlen.(text)>);
<lines.(text):{line|<variable>Builder.append("<escape.(line)>");}; separator="\n">
String <variable> = <variable>Builder.toString();
>>

writeStringLiteral(text) ::= <%
<if(isEmpty.(text))>
""
<else>
<writeLines(lines.(text))>
<endif>
%>

writeLines(textLines) ::= <%
<if(rest(textLines))>
<textLines:{line|
<\n>		"<escape.(line)>}; separator="\" +">"
<else>
"<escape.(first(textLines))>"
<endif>
%>

string(text) ::= <<
"<escape.(text)>"
>>

writeBoolean(o) ::= "<if(o && !isEmpty.(o))>true<else>false<endif>"

writeln(s) ::= "std::cout \<\< <s> \<\< std::endl;"
write(s) ::= "std::cout \<\< <s>;"
writeList(s) ::= << std::cout \<\< <s; separator=" \<\< "> \<\< std::endl;>>

False() ::= "false"
True() ::= "true"
Not(v) ::= "!<v>"
Assert(s) ::= ""
Cast(t,v) ::= "std::dynamic_pointer_cast\<<t>>(<v>)" // Should actually use a more specific name. We may have to use other casts as well.
Append(a,b) ::= "<a> + <b>->toString()"
Concat(a,b) ::= "<a><b>"

DeclareLocal(s,v) ::= "<s> = <v>"

AssertIsList(v) ::= "assert(<v>.size() >= 0);" // Use a method that exists only on a list (vector actually).
AssignLocal(s,v) ::= "<s> = <v>;"

InitIntMember(n,v) ::= "int <n> = <v>;"
InitBooleanMember(n,v) ::= "bool <n> = <v>;"

GetMember(n) ::= "<n>"
SetMember(n,v) ::= "<n> = <v>;"
AddMember(n,v) ::= "<n> += <v>;"
PlusMember(v,n) ::= "<v> + <n>"
MemberEquals(n,v) ::= "<n> == <v>"
ModMemberEquals(n,m,v) ::= "<n> % <m> == <v>"
ModMemberNotEquals(n,m,v) ::= "<n> % <m> != <v>"

DumpDFA() ::= "dumpDFA();"
Pass() ::= "/* do nothing */"

StringList() ::= "std::vector\<std::string>"
BuildParseTrees() ::= "setBuildParseTree(true);"
BailErrorStrategy() ::= "_errHandler = std::make_shared\<BailErrorStrategy>();"

ToStringTree(s) ::= "<s>->toStringTree(this)"
Column() ::= "getCharPositionInLine()"
Text() ::= "getText()"
ValEquals(a,b) ::= "<a> == <b>"
TextEquals(a) ::= "getText() == \"<a>\""
PlusText(a) ::="\"<a>\" + getText()"
InputText() ::= "_input->getText()"
LTEquals(i, v) ::= "_input->LT(<i>)->getText() == <v>"
LANotEquals(i, v) ::= "_input->LA(<i>) != <v>"
TokenStartColumnEquals(i) ::= "tokenStartCharPositionInLine == <i>"

ImportListener(X) ::= ""

GetExpectedTokenNames() ::= "getExpectedTokens().toString(_tokenNames)"

RuleInvocationStack() ::= "Arrays::listToString(getRuleInvocationStack(), \", \")"

LL_EXACT_AMBIG_DETECTION() ::= <<getInterpreter\<atn::ParserATNSimulator>()->setPredictionMode(atn::PredictionMode::LL_EXACT_AMBIG_DETECTION);>>

ParserPropertyMember() ::= <<
@members {
bool Property() {
	return true;
}
}
>>

ParserPropertyCall(p, call) ::= "<call>"

PositionAdjustingLexer() ::= <<
protected:
  class PositionAdjustingLexerATNSimulator : public atn::LexerATNSimulator {
  public:
    PositionAdjustingLexerATNSimulator(Lexer *recog, const atn::ATN &atn, std::vector\<dfa::DFA> &decisionToDFA,
                                       atn::PredictionContextCache &sharedContextCache)
      : atn::LexerATNSimulator(recog, atn, decisionToDFA, sharedContextCache) {
    }

    void resetAcceptPosition(CharStream *input, int index, int line, int charPositionInLine) {
      input->seek(index);
      _line = line;
      _charPositionInLine = charPositionInLine;
      consume(input);
    }

  };
  
public:
  virtual Token* nextToken() override {
    if (dynamic_cast\<PositionAdjustingLexerATNSimulator *>(_interpreter) == nullptr) {
      delete _interpreter;
      _interpreter = new PositionAdjustingLexerATNSimulator(this, _atn, _decisionToDFA, _sharedContextCache);
    }

    return Lexer::nextToken();
  }

  virtual Token* emit() override {
    switch (type) {
      case TOKENS:
        handleAcceptPositionForKeyword("tokens");
        break;

      case LABEL:
        handleAcceptPositionForIdentifier();
        break;

      default:
        break;
    }
    return Lexer::emit();
  }

private:
  bool handleAcceptPositionForIdentifier() {
    std::string tokenText = getText();
    int identifierLength = 0;
    while (identifierLength \< tokenText.length() && isIdentifierChar(tokenText[identifierLength])) {
      identifierLength++;
    }

    if (getInputStream()->index() > tokenStartCharIndex + identifierLength) {
      int offset = identifierLength - 1;
      getInterpreter\<PositionAdjustingLexerATNSimulator>()->resetAcceptPosition(getInputStream(),
        tokenStartCharIndex + offset, tokenStartLine, tokenStartCharPositionInLine + offset);
      return true;
    }

    return false;
  }

  bool handleAcceptPositionForKeyword(const std::string &keyword) {
    if (getInputStream()->index() > tokenStartCharIndex + keyword.length()) {
      long offset = keyword.size() - 1;
      getInterpreter\<PositionAdjustingLexerATNSimulator>()->resetAcceptPosition(getInputStream(),
        tokenStartCharIndex + offset, tokenStartLine, tokenStartCharPositionInLine + offset);
      return true;
    }

    return false;
  }

  static bool isIdentifierChar(char c) {
    return std::isalnum(c) || c == '_';
  }

public:
>>

BasicListener(X) ::= <<
@parser::definitions {
class LeafListener : public TBaseListener {
public:
  virtual void visitTerminal(Ref\<tree::TerminalNode> node) override {
  std::cout \<\< node->getSymbol()->getText() \<\< std::endl;
  }
};
}
>>

WalkListener(s) ::= <<
tree::ParseTreeWalker::DEFAULT->walk(std::make_shared\<LeafListener>(), <s>);
>>

TreeNodeWithAltNumField(X) ::= <<
@parser::members {
class MyRuleNode : public ParserRuleContext {
public:
  int altNum;
	MyRuleNode(std::weak_ptr\<ParserRuleContext> parent, int invokingStateNumber)
		: ParserRuleContext(parent, invokingStateNumber) {
	}
	virtual int getAltNumber() const override { return altNum; }
	virtual void setAltNumber(int altNum) override { this->altNum = altNum; }
};
}
>>

TokenGetterListener(X) ::= <<
@parser::definitions {
class LeafListener : public TBaseListener {
public:
  virtual void exitA(TParser::AContext *ctx) override {
		if (ctx->getChildCount() == 2)
			std::cout \<\< ctx->INT(0)->getSymbol()->getText() \<\< " " \<\< ctx->INT(1)->getSymbol()->getText()
        \<\< " " \<\< Arrays::toString(ctx->INT()) \<\< std::endl;
		else
			std::cout \<\< ctx->ID()->getSymbol()->toString() \<\< std::endl;
	}
};
}
>>

RuleGetterListener(X) ::= <<
@parser::definitions {
class LeafListener : public TBaseListener {
public:
  virtual void exitA(TParser::AContext *ctx) override {
    if (ctx->getChildCount() == 2) {
      std::cout \<\< ctx->b(0)->start->getText() \<\< " " \<\< ctx->b(1)->start->getText() \<\< " " \<\< ctx->b()[0]->start->getText() \<\< std::endl;
    } else {
      std::cout \<\< ctx->b(0)->start->getText() \<\< std::endl;
    }
  }
};
}
>>


LRListener(X) ::= <<
@parser::definitions {
class LeafListener : public TBaseListener {
public:
  virtual void exitE(TParser::EContext *ctx) override {
    if (ctx->getChildCount() == 3) {
      std::cout \<\< ctx->e(0)->start->getText() \<\< " " \<\< ctx->e(1)->start->getText() \<\< " " \<\< ctx->e()[0]->start->getText() \<\< std::endl;
    } else {
      std::cout \<\< ctx->INT()->getSymbol()->getText() \<\< std::endl;
    }
  }
};
}
>>

LRWithLabelsListener(X) ::= <<
@parser::definitions {
class LeafListener : public TBaseListener {
public:
  virtual void exitCall(TParser::CallContext *ctx) override {
    std::cout \<\< ctx->e()->start->getText() \<\< " " \<\< ctx->eList()->toString() \<\< std::endl;
	}
	virtual void exitInt(TParser::IntContext *ctx) override {
		std::cout \<\<  ctx->INT()->getSymbol()->getText() \<\< std::endl;
	}
};
}
>>

DeclareContextListGettersFunction() ::= <<
void foo() {
  Ref\<SContext> s;
  std::vector\<Ref\<AContext\>> a = s->a();
  std::vector\<Ref\<BContext\>> b = s->b();
}
>>

Declare_foo() ::= <<void foo() {
	std::cout \<\< "foo";
}
>>

Invoke_foo() ::= "foo();"

Declare_pred() ::= <<
bool pred(bool v) {
	std::cout \<\< "eval=" \<\< std::boolalpha \<\< v \<\< std::endl;
	return v;
}
>>

Invoke_pred(v) ::= <<pred(<v>)>>

ParserTokenType(t) ::= "Parser::<t>"
ContextRuleFunction(ctx, rule) ::= "<ctx>-><rule>"
StringType() ::= "std::string"
ContextMember(ctx, subctx, member) ::= "<ctx>-><subctx>-><member>"

isEmpty ::= [
	"": true,
	default: false
]
